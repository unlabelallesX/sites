<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Alexandre Draw</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/webm-muxer@5.0.2/build/webm-muxer.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Caveat:wght@700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a1a1a;
            color: #e0e0e0;
            user-select: none;
            overflow: hidden;
        }

        .panel {
            background-color: #2b2b2b;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
            border: 1px solid #3d3d3d;
        }

        #canvas-container {
            position: relative;
            background-color: #1a1a1a;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        #drawing-canvas, #onion-canvas {
            position: absolute;
            top: 0;
            left: 0;
            object-fit: contain;
            width: 100%;
            height: 100%;
            display: block;
        }

        #drawing-canvas {
            cursor: crosshair;
        }
        
        .custom-scroll::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        .custom-scroll::-webkit-scrollbar-track {
            background: #2b2b2b;
            border-radius: 10px;
        }
        .custom-scroll::-webkit-scrollbar-thumb {
            background: #555;
            border-radius: 10px;
        }
        .custom-scroll::-webkit-scrollbar-thumb:hover {
            background: #666;
        }

        .vertical-slider {
            -webkit-appearance: none;
            appearance: none;
            writing-mode: bt-lr;
            -webkit-appearance: slider-vertical;
            appearance: slider-vertical;
            width: 10px;
            height: 80px;
            background: #4a4a4a;
            outline: none;
            border-radius: 5px;
            transition: background 0.2s ease;
        }
        .vertical-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 22px;
            height: 22px;
            background: #e0e0e0;
            cursor: pointer;
            border-radius: 50%;
            border: 2px solid #3d3d3d;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
            transition: transform 0.1s ease;
        }
        .vertical-slider::-webkit-slider-thumb:hover {
            background: #fff;
            transform: scale(1.1);
        }
        .vertical-slider::-moz-range-thumb {
            width: 22px;
            height: 22px;
            background: #e0e0e0;
            cursor: pointer;
            border-radius: 50%;
            border: 2px solid #3d3d3d;
        }
        
        .icon-btn {
            transition: all 0.15s ease-in-out;
        }
        .icon-btn:hover {
            background-color: #3f3f46;
            transform: scale(1.05);
        }
        .icon-btn:active {
            transform: scale(0.95);
        }
        .icon-btn.active {
            background-color: #6366f1;
            color: #fff;
        }
        
        .timeline-frame {
            transition: all 0.2s ease-in-out;
            touch-action: none; /* Essencial para Pointer Events */
        }
        .timeline-frame.active-frame {
            border-color: #6366f1 !important;
            transform: scale(1.08);
            box-shadow: 0 0 10px rgba(99, 102, 241, 0.5);
        }
        .timeline-frame:hover {
            transform: scale(1.05);
            border-color: #4f46e5;
        }

        .timeline-frame.drag-over {
            border-color: #4CAF50 !important;
        }

        .layer-item.dragging {
            opacity: 0.4;
        }

        .audio-clip {
            position: absolute;
            height: 100%;
            cursor: move;
            box-sizing: border-box;
            background: rgba(115, 184, 255, 0.2);
            border: 1px solid rgba(115, 184, 255, 0.5);
            overflow: hidden;
            border-radius: 6px;
            z-index: 3; /* Garante que o clipe fique acima dos marcadores de frame */
        }
        .audio-clip.dragging {
             cursor: grabbing;
        }
        .waveform-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0.6;
        }
        .resize-handle {
            width: 10px;
            height: 100%;
            background-color: rgba(115, 184, 255, 0.8);
            cursor: ew-resize;
            z-index: 10;
            position: absolute;
            top: 0;
        }
        .resize-handle.left {
            left: 0;
            border-top-left-radius: 5px;
            border-bottom-left-radius: 5px;
        }
        .resize-handle.right {
            right: 0;
            border-top-right-radius: 5px;
            border-bottom-right-radius: 5px;
        }
        
        .delete-audio-btn {
            position: absolute;
            top: 0;
            left: 0;
            transform: translate(-50%, -50%);
            background-color: rgba(239, 68, 68, 0.8);
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-weight: bold;
            font-size: 12px;
            border: 1px solid white;
            z-index: 20;
            transition: transform 0.1s ease;
        }
        .delete-audio-btn:hover {
            transform: translate(-50%, -50%) scale(1.1);
        }
        .delete-audio-btn:active {
            transform: translate(-50%, -50%) scale(0.9);
        }

        /* --- NOVOS ESTILOS PARA MARCADORES DE FRAME --- */
        #timeline-content-wrapper {
            position: relative;
        }
        .frame-marker {
            position: absolute;
            top: 0;
            height: 100%; 
            width: 1px;
            background-color: rgba(255, 255, 255, 0.08);
            pointer-events: none;
            z-index: 2; /* Fica entre o fundo e os clipes de áudio */
        }

        /* --- ESTILOS DA NOVA TIMELINE EM GRADE --- */
        .timeline-row {
            display: flex;
            flex-direction: row;
            border-bottom: 1px solid #3f3f46;
            height: 44px; /* Altura fixa para cada faixa de camada */
        }
        .timeline-header {
            position: sticky;
            left: 0;
            z-index: 20;
            width: 140px; /* Largura do painel lateral de camadas */
            flex-shrink: 0;
            background-color: #27272a;
            border-right: 1px solid #52525b;
            display: flex;
            align-items: center;
            padding: 0 8px;
            font-size: 12px;
            font-weight: 500;
            color: #e4e4e7;
            box-shadow: 2px 0 5px rgba(0,0,0,0.2);
        }
        .timeline-cell {
            position: relative;
            height: 100%;
            border-right: 1px solid #3f3f46;
            flex-shrink: 0;
            cursor: pointer;
            transition: background-color 0.1s;
        }
        .timeline-cell:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }
        .timeline-cell.active-cell {
            background-color: rgba(99, 102, 241, 0.2); /* Indigo tint */
            box-shadow: inset 0 0 0 2px #6366f1;
        }
        .timeline-cell canvas {
            display: block;
            width: 100%;
            height: 100%;
            object-fit: contain;
            pointer-events: none;
        }

        #canvas-wrapper {
            background-color: #1a1a1a;
            background-image:
                linear-gradient(45deg, #252525 25%, transparent 25%),
                linear-gradient(-45deg, #252525 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #252525 75%),
                linear-gradient(-45deg, transparent 75%, #252525 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }

        /* Estilos para o Cartoon Animator 360 Integrado */
        #head-3d-wrapper { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 50; display: none; pointer-events: auto; }
        #head-3d-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; cursor: crosshair; touch-action: none; }
        #three-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: none; cursor: grab; z-index: 60; }
        .head-3d-controls { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); z-index: 100; display: flex; gap: 10px; }
        .head-btn { padding: 8px 16px; background: #00f2ff; border: none; cursor: pointer; font-weight: bold; border-radius: 4px; color: #000; font-size: 12px; box-shadow: 0 2px 5px rgba(0,0,0,0.5); }
        .head-btn:hover { filter: brightness(1.1); }
        .head-btn-animate { background: #00ff88; display: none; }
        .head-btn-reset { background: #ff4444; color: white; }
    </style>
</head>
<body class="flex flex-col h-screen p-2">

    <header class="flex-shrink-0 flex justify-between items-center mb-2">
        <div class="flex items-center space-x-4">
            <h1 class="text-2xl font-bold text-white" style="font-family: 'Caveat', cursive;">Alexandre Draw</h1>
            <div class="relative">
                <button id="file-menu-btn" class="icon-btn px-4 py-2 rounded-lg bg-zinc-700 text-sm font-medium">Arquivo</button>
                <div id="file-menu" class="hidden absolute top-full mt-2 z-50 panel w-56 p-2 flex flex-col space-y-1">
                    <button id="save-project-btn" class="w-full text-left px-3 py-2 text-sm rounded-md hover:bg-zinc-600 transition-colors">Salvar Projeto...</button>
                    <button id="load-project-btn" class="w-full text-left px-3 py-2 text-sm rounded-md hover:bg-zinc-600 transition-colors">Carregar Projeto...</button>
                    <div class="border-t border-zinc-600 my-1"></div>
                    <button id="import-image-btn" class="w-full text-left px-3 py-2 text-sm rounded-md hover:bg-zinc-600 transition-colors">Importar Imagem...</button>
                    <button id="import-sequence-btn" class="w-full text-left px-3 py-2 text-sm rounded-md hover:bg-zinc-600 transition-colors">Importar Sequência de Imagens...</button>
                    <button id="import-audio-btn" class="w-full text-left px-3 py-2 text-sm rounded-md hover:bg-zinc-600 transition-colors">Importar Áudio...</button>
                    <div class="border-t border-zinc-600 my-1"></div>
                    
                    <button id="export-png-btn" class="w-full text-left px-3 py-2 text-sm rounded-md hover:bg-zinc-600 transition-colors">Exportar como PNGs...</button>
                    <button id="export-transparent-png-btn" class="w-full text-left px-3 py-2 text-sm rounded-md hover:bg-zinc-600 transition-colors">Exportar PNGs Transparentes...</button>
                    <button id="export-layers-zip-btn" class="w-full text-left px-3 py-2 text-sm rounded-md hover:bg-zinc-600 transition-colors">Exportar Frames como Camadas (ZIP)...</button>
                    <div class="border-t border-zinc-600 my-1"></div>
                    <button id="export-video-btn" class="w-full text-left px-3 py-2 text-sm rounded-md hover:bg-zinc-600 transition-colors">Exportar como Vídeo...</button>
                    <button id="export-transparent-video-btn" class="w-full text-left px-3 py-2 text-sm rounded-md hover:bg-zinc-600 transition-colors">Exportar Vídeo Transparente...</button>
                    <button id="export-video-audio-btn" class="w-full text-left px-3 py-2 text-sm rounded-md hover:bg-zinc-600 transition-colors">Exportar como Vídeo (com Áudio)...</button>
                    <button id="export-transparent-video-audio-btn" class="w-full text-left px-3 py-2 text-sm rounded-md hover:bg-zinc-600 transition-colors">Exportar Vídeo Transparente (com Áudio)...</button>
                </div>



                <input type="file" id="load-project-input" class="hidden" accept=".adproj">
                <input type="file" id="import-image-input" class="hidden" accept="image/*">
                <input type="file" id="import-sequence-input" class="hidden" accept="image/*" multiple>
                <input type="file" id="import-audio-input" class="hidden" accept="audio/*" multiple>
            </div>
        </div>
        <div class="flex items-center space-x-4">
            <div class="relative">
                <button id="brushes-panel-btn" class="icon-btn p-2 rounded-lg bg-zinc-700" title="Pincéis">
                    <svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M17.414 2.586a2 2 0 00-2.828 0L7 10.172V13h2.828l7.586-7.586a2 2 0 000-2.828z"></path><path fill-rule="evenodd" d="M2 6a2 2 0 012-2h4a1 1 0 010 2H4v10h10v-4a1 1 0 112 0v4a2 2 0 01-2 2H4a2 2 0 01-2-2V6z" clip-rule="evenodd"></path></svg>
                </button>
            </div>
            <div class="relative">
                <button id="layers-panel-btn" class="icon-btn p-2 rounded-lg bg-zinc-700" title="Camadas">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path></svg>
                </button>
            </div>
            <div id="color-picker-wrapper" class="relative">
                <div id="color-picker-container" class="w-10 h-10 rounded-full border-2 border-zinc-500 cursor-pointer shadow-md transition-transform duration-100 ease-in-out hover:scale-105 active:scale-95" style="background-color: #000000;"></div>
                <input type="color" id="color-picker" value="#000000" class="absolute left-1/2 -ml-6 mt-2 opacity-0 pointer-events-none w-12 h-12">
            </div>
        </div>
    </header>

    <div id="brushes-panel" class="hidden absolute top-20 right-20 z-50 panel w-72 p-4 flex flex-col space-y-4 max-h-[70vh]">
        <div class="flex justify-between items-center flex-shrink-0">
            <h2 class="text-lg font-semibold text-indigo-300">Pincéis</h2>
        </div>
        <div id="brushes-list" class="flex-grow flex flex-col space-y-2 custom-scroll overflow-y-auto pr-2 min-h-0">
        </div>
    </div>


    <div id="layers-panel" class="hidden absolute top-20 right-6 z-50 panel w-72 p-4 flex flex-col space-y-4 max-h-[70vh]">
        <div class="flex justify-between items-center flex-shrink-0">
            <h2 class="text-lg font-semibold text-indigo-300">Camadas</h2>
        </div>
        <div id="layers-list" class="flex-grow space-y-2 custom-scroll overflow-y-auto pr-2 min-h-0">
        </div>
        <div class="flex-shrink-0">
            <button id="add-layer-btn" class="w-full py-2 px-4 rounded-lg bg-indigo-600 hover:bg-indigo-700 text-white font-medium transition-colors duration-200">
                Adicionar Camada
            </button>
        </div>
    </div>


    <main class="flex flex-col flex-grow space-y-2 min-h-0">
        
        <div class="flex flex-row flex-grow justify-center items-stretch space-x-6 min-h-0">
            <aside class="panel flex flex-col items-center p-2 space-y-2">
                <div class="flex flex-col items-center space-y-2">
                    <label class="text-xs text-gray-400">Tamanho</label>
                    <input type="range" id="brush-size" min="1" max="150" value="1" class="vertical-slider">
                </div>

                <div class="flex flex-col items-center justify-center py-2" title="Alternar Pincel / Borracha">
                    <label for="tool-switch" class="relative inline-flex items-center cursor-pointer">
                        <input type="checkbox" id="tool-switch" class="sr-only peer">
                        <div class="w-9 h-5 bg-zinc-600 rounded-full peer peer-checked:after:translate-x-full after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:bg-indigo-600"></div>
                    </label>
                </div>

                <div class="flex flex-col items-center space-y-2">
                    <label class="text-xs text-gray-400">Opacidade</label>
                    <input type="range" id="brush-opacity" min="1" max="100" value="100" class="vertical-slider">
                </div>
                
                <div class="border-t border-zinc-600 w-full my-2"></div>

                <div class="flex flex-row items-center space-x-2">
                    <button id="undo-btn" class="icon-btn p-1.5 rounded-full text-gray-300 bg-zinc-700" title="Desfazer (Ctrl+Z)">
                        <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24"><path d="M12.5 8c-2.65 0-5.05.99-6.91 2.61L2 7v9h9l-3.61-3.61c1.51-1.23 3.47-1.99 5.61-1.99 3.86 0 7 3.14 7 7s-3.14 7-7 7a6.9 6.9 0 01-3.95-1.15l-1.42 1.42A8.95 8.95 0 0012.5 22c4.97 0 9-4.03 9-9s-4.03-9-9-9z"/></svg>
                    </button>
                    <button id="redo-btn" class="icon-btn p-1.5 rounded-full text-gray-300 bg-zinc-700" title="Refazer (Ctrl+Y)">
                        <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24"><path d="M11.5 8c2.65 0 5.05.99 6.91 2.61L22 7v9h-9l3.61-3.61c-1.51-1.23-3.47-1.99-5.61-1.99-3.86 0-7 3.14-7 7s3.14 7 7 7a6.9 6.9 0 003.95-1.15l1.42 1.42A8.95 8.95 0 0111.5 22c-4.97 0-9-4.03-9-9s4.03-9 9-9z"/></svg>
                    </button>
                </div>

            </aside>

           <div id="canvas-container" class="flex-grow w-full flex justify-center items-center p-4">
                <div id="canvas-wrapper" class="relative w-full h-full max-w-[1920px] max-h-[1080px]">
                    <canvas id="drawing-canvas" class="z-10"></canvas>
                    <canvas id="onion-canvas" class="absolute top-0 left-0 z-20 pointer-events-none"></canvas>
                    
                    <!-- Wrapper para a ferramenta 3D -->
                    <div id="head-3d-wrapper">
                        <div class="head-3d-controls">
                            <button id="btn-animate-head" class="head-btn head-btn-animate">✨ ANIMAR</button>
                            <button id="btn-apply-head" class="head-btn" style="display:none; background:#00ff88; color:black;">✅ APLICAR</button>
                            <button id="btn-cancel-head" class="head-btn" style="display:none; background:#ff4444; color:white;">❌ CANCELAR</button>
                        </div>
                        <canvas id="head-3d-canvas"></canvas>
                        <div id="three-container"></div>
                        <canvas id="head-foreground-canvas" class="absolute top-0 left-0 w-full h-full pointer-events-none z-[70]"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <div class="w-full panel p-3 flex flex-col flex-shrink-0">
            <div class="flex items-center justify-center space-x-4 pb-3 mb-3 border-b border-zinc-700">
                <div class="flex items-center space-x-2">
                    <button id="eyedropper-btn" class="icon-btn p-2 rounded-full text-gray-300 bg-zinc-700" title="Conta-Gotas">
                            <svg class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                  <path d="M12 2.625c2.28 2.26 6 6.55 6 10.375 0 3.52-2.686 6-6 6s-6-2.48-6-6c0-3.82 3.72-8.11 6-10.375z"></path>
                            </svg>
                    </button>
                    <button id="paint-bucket-btn" class="icon-btn p-2 rounded-full text-gray-300 bg-zinc-700" title="Balde de Tinta">
                        <svg class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M5.4 19.83L6.5 21.5L9 21.5L10 20.5L12.5 23L15 20.5L16 21.5L18.5 21.5L19.6 19.83L12.5 12.75L5.4 19.83M20 7A2 2 0 0 0 18 5H6A2 2 0 0 0 4 7V11C4 11.36 4.07 11.72 4.2 12.05L12.5 3.73L20.8 12.05C20.93 11.72 21 11.36 21 11V7H20Z" /></svg>
                    </button>
                    <div class="flex items-center space-x-1">
                        <input type="range" id="fill-tolerance-slider" min="0" max="100" value="40" class="w-20 h-2 rounded-lg bg-zinc-600 cursor-pointer appearance-none" title="Tolerância do Preenchimento">
                    </div>
                    <div class="w-px h-6 bg-zinc-600 mx-1"></div>
                    <button id="onion-skin-btn" class="icon-btn p-2 rounded-full text-gray-300 bg-zinc-700" title="Ativar/Desativar Onion Skinning">
                        <svg class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24"><path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zm0 13c-3.16 0-6.09-1.39-8.11-3.61C4.78 11.23 7.85 10 12 10s7.22 1.23 8.11 2.39c-2.02 2.22-4.95 3.61-8.11 3.61zm0-10a4.5 4.5 0 100 9 4.5 4.5 0 010-9zm0 7a2.5 2.5 0 110-5 2.5 2.5 0 010 5z"/></svg>
                    </button>
                    <input type="range" id="onion-opacity-slider" min="0" max="100" value="50" class="w-24 h-2 rounded-lg bg-zinc-600 cursor-pointer appearance-none">
                    
                    <button id="selection-tool-btn" class="icon-btn p-2 rounded-full text-gray-300 bg-zinc-700" title="Ferramenta de Seleção">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" stroke-dasharray="3 3" d="M12 4.5C16.1421 4.5 19.5 7.85786 19.5 12C19.5 16.1421 16.1421 19.5 12 19.5C7.85786 19.5 4.5 16.1421 4.5 12C4.5 7.85786 7.85786 4.5 12 4.5Z"></path>
                        </svg>
                    </button>

                    <button id="puppet-tool-btn" class="icon-btn w-10 h-10 flex items-center justify-center rounded-full text-gray-300 bg-zinc-700 font-bold text-xl" title="Ferramenta de Marionete (Puppet)">
                        W
                    </button>

                    <button id="head-3d-btn" class="icon-btn w-10 h-10 flex items-center justify-center rounded-full text-gray-300 bg-zinc-700 font-bold text-sm" title="Cartoon Animator 360 (Cabeça 3D)">
                        3D
                    </button>
                </div>
                
                <div class="flex items-center space-x-2 mx-4">
                    <button id="flip-horizontal-btn" class="icon-btn p-2 rounded-full text-gray-300 bg-zinc-700" title="Virar Horizontalmente">
                        <svg class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M15 21h2v-2h-2v2zm4-12h2V7h-2v2zM3 5v14c0 1.1.9 2 2 2h4v-2H5V5h4V3H5c-1.1 0-2 .9-2 2zm16-2v2h2c0-1.1-.9-2-2-2zm-8 20h2V1h-2v22zm8-6h2v-2h-2v2zM15 5h2V3h-2v2zm4 8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2z"></path></svg>
                    </button>
                    <button id="copy-selection-btn" class="icon-btn p-2 rounded-full text-gray-300 bg-zinc-700" title="Copiar Seleção">
                        <svg class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg>
                    </button>
                    <button id="copy-all-btn" class="icon-btn p-2 rounded-full text-gray-300 bg-zinc-700" title="Copiar Tudo">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-3 7h3m-3 4h3m-6-4h.01M6 15h.01"></path></svg>
                    </button>
                    <button id="paste-selection-btn" class="icon-btn p-2 rounded-full text-gray-300 bg-zinc-700" title="Colar Seleção">
                        <svg class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24"><path d="M19 2h-4.18C14.4.84 13.3 0 12 0c-1.3 0-2.4.84-2.82 2H5c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-7 0c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm7 18H5V4h2v3h10V4h2v16z"/></svg>
                    </button>
                    <button id="play-pause-btn" class="icon-btn p-3 rounded-full text-gray-300 bg-indigo-600 hover:bg-indigo-700" title="Reproduzir / Pausar (Espaço)">
                        <svg id="play-icon" class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
                        <svg id="pause-icon" class="w-6 h-6 hidden" fill="currentColor" viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>
                    </button>
                    <button id="add-frame-btn" class="icon-btn p-2 rounded-full text-gray-300 bg-zinc-700" title="Adicionar Quadro">
                        <svg class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>
                    </button>
                    <button id="duplicate-frame-btn" class="icon-btn p-2 rounded-full text-gray-300 bg-zinc-700" title="Duplicar Quadro">
                        <svg class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M11 5H13V8H16V10H13V13H11V10H8V8H11V5M6 2C4.89543 2 4 2.89543 4 4V18C4 19.1046 4.89543 20 6 20H18C19.1046 20 20 19.1046 20 18V9H18V18H6V4H13V2H6Z"/></svg>
                    </button>
                    <button id="delete-frame-btn" class="icon-btn p-2 rounded-full text-gray-300 bg-zinc-700" title="Apagar Quadro">
                        <svg class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/></svg>
                    </button>
                    <div class="flex items-center space-x-1 ml-2 border-l border-zinc-600 pl-2" title="Duração do Quadro (Hold)">
                        <span class="text-xs text-gray-400 font-medium">Dur:</span>
                        <div class="flex items-center">
                            <input type="text" id="frame-duration-input" inputmode="none" autocomplete="off" value="1" class="w-10 h-7 bg-zinc-800 border border-zinc-600 rounded-l text-center text-xs text-white focus:outline-none focus:border-indigo-500 font-mono">
                            <div class="flex flex-col h-7">
                                <button id="btn-dur-inc" class="h-3.5 w-4 bg-zinc-700 hover:bg-zinc-600 border border-l-0 border-zinc-600 rounded-tr flex items-center justify-center text-[8px] text-gray-300">▲</button>
                                <button id="btn-dur-dec" class="h-3.5 w-4 bg-zinc-700 hover:bg-zinc-600 border border-l-0 border-t-0 border-zinc-600 rounded-br flex items-center justify-center text-[8px] text-gray-300">▼</button>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="flex items-center space-x-2">
                    <label for="fps-slider" class="text-sm font-medium text-gray-400">FPS:</label>
                    <input type="range" id="fps-slider" min="1" max="24" value="12" class="w-24 h-2 rounded-lg bg-zinc-600 cursor-pointer appearance-none">
                    <span id="fps-value" class="text-sm font-mono bg-zinc-700 px-2 py-1 rounded-md">12</span>
                </div>

                <div class="flex items-center space-x-2">
                    <label for="zoom-slider" class="text-sm font-medium text-gray-400">Zoom:</label>
                    <input type="range" id="zoom-slider" min="0.1" max="5" value="1" step="0.01" class="w-24 h-2 rounded-lg bg-zinc-600 cursor-pointer appearance-none">
                    <span id="zoom-value" class="text-sm font-mono bg-zinc-700 px-2 py-1 rounded-md">1.0x</span>
                    <button id="pan-tool-btn" class="icon-btn p-2 rounded-full text-gray-300 bg-zinc-700" title="Ferramenta Mão (Navegar)">
                        <svg class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M10.5,7A1.5,1.5 0 0,1 9,8.5A1.5,1.5 0 0,1 7.5,7A1.5,1.5 0 0,1 9,5.5A1.5,1.5 0 0,1 10.5,7M14,11.5A1.5,1.5 0 0,1 12.5,13A1.5,1.5 0 0,1 11,11.5A1.5,1.5 0 0,1 12.5,10A1.5,1.5 0 0,1 14,11.5M17,6.5A1.5,1.5 0 0,1 15.5,8A1.5,1.5 0 0,1 14,6.5A1.5,1.5 0 0,1 15.5,5A1.5,1.5 0 0,1 17,6.5M18,13A1.5,1.5 0 0,1 16.5,14.5A1.5,1.5 0 0,1 15,13A1.5,1.5 0 0,1 16.5,11.5A1.5,1.5 0 0,1 18,13M19.5,18.23L17.03,16.12C16.5,15.78 15.83,15.92 15.41,16.38L12.31,20.2C11.85,20.74 11.03,20.81 10.4,20.4L6.5,17.78C5.88,17.38 5.75,16.5 6.19,15.9L8.5,12.8C8.8,12.43 8.7,11.86 8.27,11.58L6.15,10.1C5.61,9.73 4.87,9.93 4.5,10.45L2.23,13.43C1.5,14.33 1.95,15.73 3.03,16.3L8.2,19.53C8.5,19.7 8.84,19.79 9.18,19.79C10.13,19.79 11.05,19.23 11.5,18.43L14.5,14.54C14.8,14.17 15.35,13.97 15.88,14.2L18.96,15.87C20.05,16.46 20.5,17.85 19.5,18.23Z"></path>
                        </svg>
                    </button>
                </div>

            </div>
            <!-- Container de rolagem principal para toda a timeline -->
            <div id="timeline-container" class="custom-scroll overflow-auto" style="max-height: 120px; min-height: 120px;">
                <!-- Wrapper de conteúdo que se expande para acomodar tudo -->
                <div id="timeline-content-wrapper" class="relative min-w-full">                    
                    <div id="timeline-frames" class="flex flex-col min-w-full">
                        <!-- A GRADE DA TIMELINE SERÁ INJETADA AQUI -->
                    </div>
                    <div id="audio-track-container" class="mt-2 h-[50px] bg-zinc-800/50 rounded-lg relative flex">
                        <div class="timeline-header h-full rounded-l-lg border-r border-zinc-600 bg-zinc-800 z-20 flex items-center px-2 text-xs font-medium text-gray-400">
                            Áudios
                        </div>
                        <div id="audio-timeline-wrapper" class="h-full relative flex-grow"></div>
                    </div>
                </div>
            </div>
        </div>
    </main>
    
    <div id="message-modal" class="hidden fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-[101]">
        <div class="panel p-6 rounded-lg max-w-sm w-full flex flex-col space-y-4">
            <h3 id="message-title" class="text-lg font-semibold text-white">Título</h3>
            <p id="message-text" class="text-gray-300"></p>
            <button id="message-ok-btn" class="w-full py-2 px-4 rounded-lg bg-indigo-600 hover:bg-indigo-700 text-white font-medium transition-colors duration-200">OK</button>
        </div>
    </div>
    
    <div id="loading-modal" class="hidden fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-[100]">
        <div class="panel p-6 rounded-lg flex flex-col items-center space-y-4">
            <svg class="animate-spin h-8 w-8 text-indigo-400" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            <p id="loading-message" class="text-lg font-medium text-gray-300">Processando...</p>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script>
        // Correção do bug de redimensionamento
        if (window.top === window) {
            window.resizeTo(screen.width, screen.height);
            window.moveTo(0, 0);
        }

        document.addEventListener('DOMContentLoaded', () => {

            const CANVAS_WIDTH = 2048;
            const CANVAS_HEIGHT = 1024;

            // --- 1. MEMORY VIRTUALIZATION (DISK-PAGING) ---
            const FrameManager = {
                db: null,
                cache: new Map(), // LRU Cache for active frames
                MAX_CACHE: 50,

                async init() {
                    return new Promise((resolve, reject) => {
                        const req = indexedDB.open('AlexandreDraw_SwapFile', 1);
                        req.onupgradeneeded = e => {
                            if (!e.target.result.objectStoreNames.contains('frames')) {
                                e.target.result.createObjectStore('frames');
                            }
                        };
                        req.onsuccess = e => { this.db = e.target.result; resolve(); };
                    });
                },

                async saveFrameToDisk(id, blob) {
                    if (!this.db) await this.init();
                    const tx = this.db.transaction('frames', 'readwrite');
                    tx.objectStore('frames').put(blob, id);
                    // Aggressive RAM Cleanup
                    if (this.cache.size > this.MAX_CACHE) {
                        const firstKey = this.cache.keys().next().value;
                        const oldBitmap = this.cache.get(firstKey);
                        if (oldBitmap && oldBitmap.close) oldBitmap.close(); // Manual GC
                        this.cache.delete(firstKey);
                    }
                },

                async getFrame(id) {
                    if (this.cache.has(id)) return this.cache.get(id);
                    if (!this.db) await this.init();
                    return new Promise(resolve => {
                        const req = this.db.transaction('frames', 'readonly').objectStore('frames').get(id);
                        req.onsuccess = async () => {
                            if (req.result) {
                                const bmp = await createImageBitmap(req.result);
                                this.cache.set(id, bmp);
                                resolve(bmp);
                            } else resolve(null);
                        };
                    });
                }
            };
            FrameManager.init();

            const canvasWrapper = document.getElementById('canvas-wrapper');
           // FUNÇÃO CORRIGIDA: Garante que o canvas nunca tenha tamanho 0
           // FUNÇÃO CORRIGIDA: Garante que o canvas nunca tenha tamanho 0
            const resizeCanvas = () => {
                const parent = canvasWrapper.parentElement;
                // Garante valores mínimos se o pai ainda não carregou
                const parentWidth = parent.clientWidth || window.innerWidth * 0.8;
                const parentHeight = parent.clientHeight || window.innerHeight * 0.6;
                
                const canvasRatio = CANVAS_WIDTH / CANVAS_HEIGHT;
                const parentRatio = parentWidth / parentHeight;

                if (parentRatio > canvasRatio) {
                    canvasWrapper.style.height = `${parentHeight}px`;
                    canvasWrapper.style.width = `${parentHeight * canvasRatio}px`;
                } else {
                    canvasWrapper.style.width = `${parentWidth}px`;
                    canvasWrapper.style.height = `${parentWidth / canvasRatio}px`;
                }
                
                // Força reaplicar o zoom/pan para centralizar se necessário
                applyTransform();
            };


            window.addEventListener('resize', resizeCanvas);
            
            setTimeout(() => {
                resizeCanvas();
            }, 100);

            // DOM Elements
            const mainCanvas = document.getElementById('drawing-canvas');
            const onionCanvas = document.getElementById('onion-canvas');
            const brushSizeSlider = document.getElementById('brush-size');
            const brushOpacitySlider = document.getElementById('brush-opacity');
            const colorPicker = document.getElementById('color-picker');
            const colorPickerContainer = document.getElementById('color-picker-container');
            const timelineFrames = document.getElementById('timeline-frames');
            const playPauseBtn = document.getElementById('play-pause-btn');
            const addFrameBtn = document.getElementById('add-frame-btn');
            const duplicateFrameBtn = document.getElementById('duplicate-frame-btn');
            const deleteFrameBtn = document.getElementById('delete-frame-btn');
            const frameDurationInput = document.getElementById('frame-duration-input');
            const btnDurInc = document.getElementById('btn-dur-inc');
            const btnDurDec = document.getElementById('btn-dur-dec');
            const layersList = document.getElementById('layers-list');
            const addLayerBtn = document.getElementById('add-layer-btn');
            const onionSkinBtn = document.getElementById('onion-skin-btn');
            const onionOpacitySlider = document.getElementById('onion-opacity-slider');
            const undoBtn = document.getElementById('undo-btn');
            const redoBtn = document.getElementById('redo-btn');
            const layersPanelBtn = document.getElementById('layers-panel-btn');
            const layersPanel = document.getElementById('layers-panel');
            const brushesPanelBtn = document.getElementById('brushes-panel-btn');
            const brushesPanel = document.getElementById('brushes-panel');
            const brushesList = document.getElementById('brushes-list');
            const fpsSlider = document.getElementById('fps-slider');
            const fpsValue = document.getElementById('fps-value');
            const selectionToolBtn = document.getElementById('selection-tool-btn');
            const panToolBtn = document.getElementById('pan-tool-btn');
            const paintBucketBtn = document.getElementById('paint-bucket-btn');
            const eyedropperBtn = document.getElementById('eyedropper-btn');
            const toolSwitch = document.getElementById('tool-switch');
            const fillToleranceSlider = document.getElementById('fill-tolerance-slider');
            const copySelectionBtn = document.getElementById('copy-selection-btn');
            const pasteSelectionBtn = document.getElementById('paste-selection-btn');
            const copyAllBtn = document.getElementById('copy-all-btn');
            const zoomSlider = document.getElementById('zoom-slider');
            const zoomValue = document.getElementById('zoom-value');
            const flipHorizontalBtn = document.getElementById('flip-horizontal-btn'); 
            const puppetToolBtn = document.getElementById('puppet-tool-btn');
            
            // 3D Head Tool Elements
            const head3dBtn = document.getElementById('head-3d-btn');
            const head3dWrapper = document.getElementById('head-3d-wrapper');
            const head3dCanvas = document.getElementById('head-3d-canvas');
            const threeContainer = document.getElementById('three-container');
            const headForegroundCanvas = document.getElementById('head-foreground-canvas');
            const btnAnimateHead = document.getElementById('btn-animate-head');
            const btnApplyHead = document.getElementById('btn-apply-head');
            const btnCancelHead = document.getElementById('btn-cancel-head');
            
            // File Menu Elements
            const fileMenuBtn = document.getElementById('file-menu-btn');
            const fileMenu = document.getElementById('file-menu');
            const saveProjectBtn = document.getElementById('save-project-btn');
            const loadProjectBtn = document.getElementById('load-project-btn');
            const loadProjectInput = document.getElementById('load-project-input');
            const importImageBtn = document.getElementById('import-image-btn');
            const importImageInput = document.getElementById('import-image-input');
            const importSequenceBtn = document.getElementById('import-sequence-btn');
            const importSequenceInput = document.getElementById('import-sequence-input');
            const importAudioBtn = document.getElementById('import-audio-btn');
            const importAudioInput = document.getElementById('import-audio-input');

            const exportPngBtn = document.getElementById('export-png-btn');
            const exportTransparentPngBtn = document.getElementById('export-transparent-png-btn');
            const exportLayersZipBtn = document.getElementById('export-layers-zip-btn'); 
            const exportVideoBtn = document.getElementById('export-video-btn');
            const exportTransparentVideoBtn = document.getElementById('export-transparent-video-btn');
            const exportVideoAudioBtn = document.getElementById('export-video-audio-btn');
            const exportTransparentVideoAudioBtn = document.getElementById('export-transparent-video-audio-btn');    
            const loadingModal = document.getElementById('loading-modal');
            const loadingMessage = document.getElementById('loading-message');
            const messageModal = document.getElementById('message-modal');
            const messageTitle = document.getElementById('message-title');
            const messageText = document.getElementById('message-text');
            const messageOkBtn = document.getElementById('message-ok-btn');
            const audioTrackContainer = document.getElementById('audio-track-container');
            const audioTimelineWrapper = document.getElementById('audio-timeline-wrapper');
            const timelineContentWrapper = document.getElementById('timeline-content-wrapper');
            
            // Canvas & Contexts
            const ctx = mainCanvas.getContext('2d', { willReadFrequently: true });
            const onionCtx = onionCanvas.getContext('2d');
            
            // Set canvas dimensions
            [mainCanvas, onionCanvas].forEach(canvas => {
                canvas.width = CANVAS_WIDTH;
                canvas.height = CANVAS_HEIGHT;
            });

            // --- OTIMIZAÇÃO: Canvas compartilhado para composição de camadas ---
            // Evita criar um novo elemento canvas a cada renderização de frame/miniatura
            const sharedTempLayerCanvas = document.createElement('canvas');
            sharedTempLayerCanvas.width = CANVAS_WIDTH;
            sharedTempLayerCanvas.height = CANVAS_HEIGHT;
            const sharedTempLayerCtx = sharedTempLayerCanvas.getContext('2d', { willReadFrequently: true });
            
            // --- OTIMIZAÇÃO: Canvas de Cache para o Fundo durante o desenho ---
            const drawingBackgroundCanvas = document.createElement('canvas');
            drawingBackgroundCanvas.width = CANVAS_WIDTH;
            drawingBackgroundCanvas.height = CANVAS_HEIGHT;

            // --- NOVO: Canvas para o traço em andamento ---
            // Este canvas irá conter a "forma" do traço, sem opacidade,
            // para evitar o acúmulo de transparência durante o desenho.
            const strokeCanvas = document.createElement('canvas');
            strokeCanvas.width = CANVAS_WIDTH;
            strokeCanvas.height = CANVAS_HEIGHT;
            const strokeCtx = strokeCanvas.getContext('2d');
            
            // Canvas auxiliar para redimensionamento de thumbnails da timeline
            const thumbResizerCanvas = document.createElement('canvas');
            thumbResizerCanvas.width = 54; // Largura padrão do thumbnail
            thumbResizerCanvas.height = 30;
            const thumbResizerCtx = thumbResizerCanvas.getContext('2d');


            // State
            let globalBackgroundLayer = null;
            let isDrawing = false;

            // Navegação
            let scale = 1;
            let panX = 0;
            let panY = 0;
            let isPanning = false;
            let startPanX = 0;
            let startPanY = 0;

            // Suavização de Traço
            let smoothPointer = { x: 0, y: 0 };
            const SMOOTH_FACTOR = 0.35; // Quanto menor, mais suave (e mais lento)


            
            // --- INÍCIO DA CORREÇÃO DO BUG DOS PINCÉIS ---
            const brushesConfig = {
                'normal':   { size: 3, opacityValue: 100, spacing: 0.1 },
                'pencil':   { size: 1, opacityValue: 100, spacing: 0.25 },
                'spray':    { size: 40, opacityValue: 100, spacing: 0.1 },
                'airbrush': { size: 150, opacityValue: 100, spacing: 0.05 }
            };

            let currentBrush = {
                size: brushesConfig.pencil.size,
                opacity: 1.0, // Será recalculado pela lógica do slider
                color: colorPicker.value,
                type: 'pencil'
            };

            // --- NOVO MOTOR DE PINCÉIS (Estilo Procreate) ---
            const brushTextures = {};
            const activeBrushCanvas = document.createElement('canvas'); // Cache da ponta do pincel colorido
            activeBrushCanvas.width = 64; activeBrushCanvas.height = 64;

            function initBrushTextures() {
                const create = (w, h, fn) => {
                    const c = document.createElement('canvas');
                    c.width = w; c.height = h;
                    fn(c.getContext('2d'), w, h);
                    return c;
                };

                // 1. Normal: Gradiente suave para traços limpos
                brushTextures.normal = create(64, 64, (ctx, w, h) => {
                    const g = ctx.createRadialGradient(w/2, h/2, 0, w/2, h/2, w/2);
                    g.addColorStop(0, 'black');
                    g.addColorStop(1, 'transparent');
                    ctx.fillStyle = g;
                    ctx.fillRect(0, 0, w, h);
                });

                // 2. Pencil: Textura de ruído para parecer grafite
                brushTextures.pencil = create(64, 64, (ctx, w, h) => {
                    for(let i=0; i<800; i++) {
                        // Concentra mais no centro
                        const r = (Math.random() * w/2) * Math.sqrt(Math.random());
                        const a = Math.random() * 2 * Math.PI;
                        ctx.fillStyle = `rgba(0,0,0,${0.2 + Math.random() * 0.5})`;
                        ctx.fillRect(w/2 + r*Math.cos(a), h/2 + r*Math.sin(a), 1.5, 1.5);
                    }
                });
                
                // 3. Spray: Partículas dispersas
                brushTextures.spray = create(128, 128, (ctx, w, h) => {
                    for(let i=0; i<300; i++) {
                        const r = Math.random() * (w/2);
                        const a = Math.random() * 2 * Math.PI;
                        // Decaimento suave nas bordas
                        const alpha = 1 - (r / (w/2));
                        ctx.fillStyle = `rgba(0,0,0,${alpha * 0.8})`;
                        ctx.fillRect(w/2 + r*Math.cos(a), h/2 + r*Math.sin(a), 2, 2);
                    }
                });

                // 4. Airbrush: Gradiente suave e uniforme
                brushTextures.airbrush = create(128, 128, (ctx, w, h) => {
                    const g = ctx.createRadialGradient(w/2, h/2, 0, w/2, h/2, w/2);
                    // Começa sólido no centro e desaparece completamente nas bordas,
                    // criando um efeito de aerógrafo mais uniforme, sem um ponto central escuro.
                    g.addColorStop(0, 'black'); 
                    g.addColorStop(1, 'transparent');
                    ctx.fillStyle = g;
                    ctx.fillRect(0, 0, w, h);
                });
            }

            function updateActiveBrushTip() {
                const texture = brushTextures[currentBrush.type] || brushTextures.normal;
                activeBrushCanvas.width = texture.width;
                activeBrushCanvas.height = texture.height;
                const ctx = activeBrushCanvas.getContext('2d');
                
                // 1. Desenha a textura base
                ctx.drawImage(texture, 0, 0);
                
                // 2. Colore a textura usando source-in (mantém o alfa da textura, troca a cor)
                ctx.globalCompositeOperation = 'source-in';
                ctx.fillStyle = currentBrush.color;
                ctx.fillRect(0, 0, activeBrushCanvas.width, activeBrushCanvas.height);
            }
            
            function updateBrushUI(type) {
                if (!brushesConfig[type]) return;
                
                const config = brushesConfig[type];
                brushSizeSlider.value = config.size;
                brushOpacitySlider.value = config.opacityValue;

                // Dispara o evento 'input' manualmente para recalcular a opacidade e o tamanho
                brushOpacitySlider.dispatchEvent(new Event('input'));
                brushSizeSlider.dispatchEvent(new Event('input'));
                updateActiveBrushTip();
            }
            // --- FIM DA CORREÇÃO DO BUG DOS PINCÉIS ---

            let timelineFramesData = [];
            let currentLayerIndex = 1;
            let preferredLayerIndex = 1;
            let currentFrameIndex = 0;
            let selectedFrameIndices = new Set([0]);
            let frameRate = 12; 
            let isPlaying = false;
            let playbackStartTime = 0; // For Audio Sync
            let animationId;
            let lastFrameTime = 0;
            let onionSkinning = false;
            let onionOpacity = 0.5;
            let lastX = 0;
            let lastY = 0;
            let frameHoldCounter = 0; // Contador para duração do frame
            const MAX_HISTORY_STATES = 25;

            // Tool State
            let currentTool = 'brush'; // 'brush', 'eraser', 'selection', 'puppet', 'bucket', 'eyedropper', 'pan'
            let isSelecting = false;
            let isDrawingPuppetLasso = false;
            let selectionPath = [];
            let fillTolerance = parseInt(fillToleranceSlider.value);
            
            // 3D Head State
            let headPoints = [];
            let isHeadClosed = false;
            let isDrawingHead = false;
            let headImg = new Image();
            let headScene, headCamera, headRenderer, headMesh;
            let rotX = 0, rotY = 0;
            let headAnimationId;
            let head3dCtx = head3dCanvas.getContext('2d');

            let warpGrid = null; 
            let selectionCanvas = null;
            let selectionTransform = { x: 0, y: 0, width: 0, height: 0, rotation: 0 };
            let activeHandle = null;
            let activeWarpNode = null; // Para saber qual ponto estamos arrastando
            let clipboardSelection = null;
            let puppetPins = []; // Para a nova ferramenta de marionete
            let puppets = []; // Array para múltiplos bonecos (puppets)
            const HANDLE_SIZE = 40; // Alteração: Aumentado em 4x para melhor usabilidade
            let dragStart = { x: 0, y: 0 };
            let initialTransform = {};
            let tempDrawCanvas = null;

            // Audio State
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            let audioContext = null;
            let audioTracks = [];
            let activeAudioSources = [];
            let audioBufferSourceNode = null;
            
            // --- Funções Principais ---

            // FUNÇÃO LEVE: Atualiza apenas o painel de camadas e os botões de histórico
            function updateLayerPanelAndHistoryIndicators() {
                const currentLayers = timelineFramesData[currentFrameIndex]?.layers || [];
                const currentLayer = currentLayers[currentLayerIndex];

                // Sincroniza o seletor de cor principal com a camada selecionada
                if (currentLayer && currentLayer.isBackground) {
                    colorPicker.value = currentLayer.backgroundColor || '#ffffff';
                    colorPickerContainer.style.backgroundColor = currentLayer.backgroundColor || '#ffffff';
                } else {
                    colorPicker.value = currentBrush.color;
                    colorPickerContainer.style.backgroundColor = currentBrush.color;
                }

                layersList.innerHTML = '';
                // Reverse the layers for display
                currentLayers.slice().reverse().forEach((layer, revIndex) => {
                    const index = currentLayers.length - 1 - revIndex;
                    const layerDiv = document.createElement('div');
                    layerDiv.className = `layer-item flex flex-col p-2 bg-zinc-700 rounded-lg shadow-sm transition-colors duration-150 space-y-2`;
                    
                    if (layer.isBackground) {
                        layerDiv.classList.add('cursor-not-allowed');
                    } else {
                        layerDiv.classList.add('cursor-grab');
                        layerDiv.setAttribute('draggable', 'true');
                    }

                    if (index === currentLayerIndex) {
                        layerDiv.classList.add('bg-indigo-900/50', 'border', 'border-indigo-500');
                    }
                    layerDiv.dataset.layerIndex = index;
                    
                    const topRow = document.createElement('div');
                    topRow.className = 'flex items-center justify-between';
                    
                    const nameContainer = document.createElement('div');
                    nameContainer.className = 'flex items-center space-x-2 flex-grow';

                    const visibilityBtn = document.createElement('button');
                    visibilityBtn.className = 'toggle-visibility icon-btn p-1 rounded-full';
                    visibilityBtn.title = 'Alternar visibilidade';
                    visibilityBtn.innerHTML = `<svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20"><path d="M10 12.5a2.5 2.5 0 11-5 0 2.5 2.5 0 015 0z" /><path fill-rule="evenodd" d="M.458 10C1.732 5.943 5.522 3 10 3s8.268 2.943 9.542 7c-1.274 4.057-5.064 7-9.542 7S1.732 14.057.458 10zM14 10a4 4 0 11-8 0 4 4 0 018 0z" clip-rule="evenodd" /></svg>`;
                    if (!layer.visible) visibilityBtn.classList.add('opacity-40');
                    
                    const layerNameSpan = document.createElement('span');
                    layerNameSpan.className = 'layer-name text-sm font-medium';
                    layerNameSpan.textContent = layer.name;
                    
                    nameContainer.append(visibilityBtn, layerNameSpan); 
                    
                    topRow.appendChild(nameContainer);

                    if (!layer.isBackground) {
                        const renameBtn = document.createElement('button');
                        renameBtn.className = 'rename-layer icon-btn p-1 rounded-full flex-shrink-0 mr-1 text-gray-400 hover:text-white';
                        renameBtn.title = 'Renomear camada';
                        renameBtn.innerHTML = `<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path></svg>`;
                        topRow.appendChild(renameBtn);
                    }
                    
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'delete-layer icon-btn p-1 rounded-full flex-shrink-0';
                    deleteBtn.title = 'Apagar camada';                     
                    if(layer.isBackground) {
                        deleteBtn.innerHTML = `<svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20" style="opacity: 0.2;"><path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd" /></svg>`;
                        deleteBtn.disabled = true;
                        deleteBtn.style.cursor = 'not-allowed';
                    } else {
                        deleteBtn.innerHTML = `<svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd" /></svg>`;
                    }
                    topRow.appendChild(deleteBtn);

                    const bottomRow = document.createElement('div');
                    bottomRow.className = 'flex items-center space-x-2';
                    
                    const opacityLabel = document.createElement('label');
                    opacityLabel.className = "text-xs text-gray-400";
                    opacityLabel.textContent = "Op:";
                    bottomRow.appendChild(opacityLabel);

                    const opacitySlider = document.createElement('input');
                    opacitySlider.type = 'range';
                    opacitySlider.className = 'layer-opacity-slider w-full h-1 bg-zinc-600 rounded-lg appearance-none cursor-pointer';
                    opacitySlider.min = 0; opacitySlider.max = 100; opacitySlider.value = layer.opacity * 100;
                    
                    bottomRow.appendChild(opacitySlider);
                    layerDiv.append(topRow, bottomRow);
                    layersList.appendChild(layerDiv);
                });

                // Atualiza o estado dos botões Desfazer/Refazer
                undoBtn.disabled = !currentLayer || currentLayer.historyIndex === 0;
                redoBtn.disabled = !currentLayer || currentLayer.historyIndex === currentLayer.history.length - 1;
            }

            // --- OTIMIZAÇÃO 2: Limite Inteligente de Histórico ---
            function consolidateHistory(frameIndex) {
                timelineFramesData[frameIndex]?.layers.forEach(layer => {
                    layer.history = [layer.history[layer.historyIndex]];
                    layer.historyIndex = 0;
                });
            }

            function refreshTimelineSelectionUI() {
                // Atualiza a seleção na grade da timeline
                const cells = timelineFrames.querySelectorAll('.timeline-cell');
                cells.forEach(cell => {
                    const fIdx = parseInt(cell.dataset.frameIndex);
                    const lIdx = parseInt(cell.dataset.layerIndex);
                    
                    // Remove classes antigas
                    cell.classList.remove('active-cell', 'bg-indigo-500/20');

                    // Seleção de Frame (Coluna)
                    if (selectedFrameIndices.has(fIdx)) {
                        cell.classList.add('bg-indigo-500/20');
                    }
                    // Célula Ativa (Frame + Layer)
                    if (fIdx === currentFrameIndex && lIdx === currentLayerIndex) {
                        cell.classList.add('active-cell');
                    }
                });
                
                // Atualiza input de duração
                if (timelineFramesData[currentFrameIndex]) {
                    frameDurationInput.value = timelineFramesData[currentFrameIndex].duration || 1;
                }
            }

            // NOVA FUNÇÃO: Atualiza apenas a miniatura do quadro ativo (Performance Fix)
            function updateCurrentFrameThumbnail() {
                // Na nova timeline em grade, precisamos atualizar a célula específica
                // da camada atual no frame atual.
                const cellSelector = `.timeline-cell[data-frame-index="${currentFrameIndex}"][data-layer-index="${currentLayerIndex}"] canvas`;
                const cellCanvas = timelineFrames.querySelector(cellSelector);
                
                if (cellCanvas) {
                    const layer = timelineFramesData[currentFrameIndex].layers[currentLayerIndex];
                    const ctx = cellCanvas.getContext('2d');
                    ctx.clearRect(0, 0, cellCanvas.width, cellCanvas.height);
                    
                    if (layer && layer.history[layer.historyIndex]) {
                        // Redimensiona e desenha
                        createImageBitmap(layer.history[layer.historyIndex]).then(bmp => {
                            ctx.drawImage(bmp, 0, 0, cellCanvas.width, cellCanvas.height);
                            bmp.close();
                        });
                    }
                }
            }


            function showMessage(title, message) {
                messageTitle.textContent = title;
                messageText.textContent = message;
                messageModal.classList.remove('hidden');
            }
            
            messageOkBtn.addEventListener('click', () => {
                messageModal.classList.add('hidden');
            });
            
            function createLayer(name, options = {}) {
                const { isBackground = false, fillWhite = false } = options;
                
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = CANVAS_WIDTH;
                tempCanvas.height = CANVAS_HEIGHT;
                const tempCtx = tempCanvas.getContext('2d');

                if (fillWhite) {
                    tempCtx.fillStyle = 'white';
                    tempCtx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                }

                const initialImageData = tempCtx.getImageData(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                return { 
                    name, 
                    visible: true, 
                    opacity: 1.0, 
                    blendMode: 'source-over',
                    isBackground,
                    backgroundColor: fillWhite ? '#ffffff' : '#ffffff',
                    history: [initialImageData], 
                    historyIndex: 0 
                };
            }
            
            // OPTIMIZED DUPLICATE LAYER FUNCTION
            function duplicateLayerOptimized(layer) {
                const newImageData = new ImageData(
                    new Uint8ClampedArray(layer.history[layer.historyIndex].data),
                    layer.history[layer.historyIndex].width,
                    layer.history[layer.historyIndex].height
                );
                return {
                    name: layer.name,
                    visible: true,
                    opacity: layer.opacity,
                    blendMode: layer.blendMode || 'source-over',
                    isBackground: layer.isBackground,
                    history: [newImageData],
                    historyIndex: 0
                };
            }

            function drawCheckerboard(context, width, height) {
                const size = 10;
                context.fillStyle = '#1a1a1a'; // Fundo do container
                context.fillRect(0, 0, width, height);
                context.fillStyle = '#3d3d3d'; // Cor escura
                for (let y = 0; y < height; y += size) {
                    for (let x = 0; x < width; x += size) {
                        if ((x / size + y / size) % 2 === 0) {
                             context.fillStyle = '#4a4a4a'; // Cor clara
                             context.fillRect(x, y, size, size);
                        } else {
                             context.fillStyle = '#3d3d3d'; // Cor escura
                             context.fillRect(x, y, size, size);
                        }
                    }
                }
            }

            // --- NOVA FUNÇÃO PARA DESENHAR MARCADORES DE FRAME ---
            function drawFrameMarkers() {
                // O container agora é o wrapper geral
                if (!timelineContentWrapper) return;

                // Remove marcadores antigos para evitar duplicação
                timelineContentWrapper.querySelectorAll('.frame-marker').forEach(marker => marker.remove());

                const FRAME_WIDTH = 54; // Largura do thumbnail do frame (w-[54px])
                const FRAME_SPACING = 0; // Espaço entre os frames (Removido para alinhar com a grade)
                const slotWidth = FRAME_WIDTH + FRAME_SPACING;
                const HEADER_WIDTH = 140; // Largura do cabeçalho da camada
                let currentX = 0;

                // Desenha marcadores baseados na duração acumulada
                timelineFramesData.forEach(frame => {
                    const duration = frame.duration || 1;
                    currentX += duration * slotWidth;

                    const marker = document.createElement('div');
                    marker.className = 'frame-marker';
                    marker.style.left = `${HEADER_WIDTH + currentX - FRAME_SPACING/2}px`; // Ajuste visual + Offset do Header
                    timelineContentWrapper.appendChild(marker);
                });
            }

            // --- NOVA FUNÇÃO OTIMIZADA DE RENDERIZAÇÃO ---
            // Renderiza um frame diretamente em um contexto existente, usando o canvas compartilhado
            function renderFrameToContext(frameIndex, destCtx, transparent = false) {
                const frameData = timelineFramesData[frameIndex];
                if (!frameData) return;

                // Limpa o destino
                if (!transparent) {
                    destCtx.fillStyle = '#ffffff';
                    destCtx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                } else {
                    destCtx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                }

                for (const layer of frameData.layers) {
                    if (layer.visible && (!transparent || !layer.isBackground)) {
                        const layerImageData = layer.history[layer.historyIndex];
                        if (layerImageData) {
                            // Usa o canvas compartilhado para evitar alocações de memória
                            sharedTempLayerCtx.putImageData(layerImageData, 0, 0);
                            destCtx.globalAlpha = layer.opacity;
                            destCtx.globalCompositeOperation = layer.blendMode || 'source-over';
                            destCtx.drawImage(sharedTempLayerCanvas, 0, 0);
                        }
                    }
                }
                destCtx.globalAlpha = 1.0;
                destCtx.globalCompositeOperation = 'source-over';
            }

            function updateUI() {
                // --- RENDERIZAÇÃO DA TIMELINE EM GRADE (GRID) ---
                timelineFrames.innerHTML = '';
                
                if (timelineFramesData.length === 0) return;

                // Usa o primeiro frame como referência para a estrutura de camadas
                const referenceLayers = timelineFramesData[0].layers;
                const THUMB_WIDTH = 54;
                const THUMB_HEIGHT = 30;
                const FRAME_SPACING = 0; // Espaço removido para alinhar

                // --- HEADER DE NÚMEROS DE FRAME ---
                const headerRow = document.createElement('div');
                headerRow.className = 'timeline-row';
                headerRow.style.height = '22px';
                headerRow.style.position = 'sticky';
                headerRow.style.top = '0';
                headerRow.style.zIndex = '30';
                headerRow.style.backgroundColor = '#18181b';
                headerRow.style.borderBottom = '1px solid #3f3f46';

                const corner = document.createElement('div');
                corner.className = 'timeline-header';
                corner.style.height = '100%';
                corner.style.zIndex = '40';
                corner.textContent = '';
                headerRow.appendChild(corner);

                for (let f = 0; f < timelineFramesData.length; f++) {
                    const duration = timelineFramesData[f].duration || 1;
                    const cellWidth = (THUMB_WIDTH * duration) + (FRAME_SPACING * (duration - 1));
                    const num = document.createElement('div');
                    num.style.width = `${cellWidth}px`;
                    num.style.flexShrink = '0';
                    num.style.borderRight = '1px solid #3f3f46';
                    num.style.display = 'flex';
                    num.style.alignItems = 'center';
                    num.style.justifyContent = 'center';
                    num.style.fontSize = '10px';
                    num.style.color = '#a1a1aa';
                    num.style.userSelect = 'none';
                    num.textContent = (f + 1).toString();
                    headerRow.appendChild(num);
                }
                timelineFrames.appendChild(headerRow);

                // Itera sobre as camadas (de cima para baixo visualmente, ou seja, índice reverso)
                // Em animação, a camada do topo (índice maior) geralmente fica em cima na lista.
                for (let l = referenceLayers.length - 1; l >= 0; l--) {
                    // Pula a camada de background na visualização da timeline para economizar espaço
                    if (referenceLayers[l].isBackground) continue;

                    const layerIndex = l;
                    const layerName = referenceLayers[l].name;

                    // Cria a LINHA da camada
                    const row = document.createElement('div');
                    row.className = 'timeline-row';

                    // Cria o CABEÇALHO da camada (Fixo à esquerda)
                    const header = document.createElement('div');
                    header.className = 'timeline-header';
                    header.innerHTML = `<span class="truncate w-full" title="${layerName}">${layerName}</span>`;
                    
                    // Destaque se for a camada ativa
                    if (l === currentLayerIndex) {
                        header.style.color = '#818cf8'; // Indigo-400
                        header.style.borderRight = '2px solid #6366f1';
                    }

                    // Clique no cabeçalho seleciona a camada
                    header.addEventListener('click', () => {
                        if (selectionCanvas) applyAndSaveTransformation();
                        currentLayerIndex = layerIndex;
                        preferredLayerIndex = layerIndex;
                        updateUI(); // Re-renderiza para atualizar destaques
                        renderCanvas();
                    });

                    row.appendChild(header);

                    // Cria as CÉLULAS (Frames) para esta camada
                    for (let f = 0; f < timelineFramesData.length; f++) {
                        const frameData = timelineFramesData[f];
                        const layerData = frameData.layers[l];
                        const duration = frameData.duration || 1;
                        const cellWidth = (THUMB_WIDTH * duration) + (FRAME_SPACING * (duration - 1));

                        const cell = document.createElement('div');
                        cell.className = 'timeline-cell';
                        cell.style.width = `${cellWidth}px`;
                        cell.dataset.frameIndex = f;
                        cell.dataset.layerIndex = l;

                        // Destaques de Seleção
                        if (selectedFrameIndices.has(f)) {
                            cell.classList.add('bg-indigo-500/20');
                        }
                        if (f === currentFrameIndex && l === currentLayerIndex) {
                            cell.classList.add('active-cell');
                        }

                        // Conteúdo da Célula (Miniatura da Camada)
                        const cellCanvas = document.createElement('canvas');
                        cellCanvas.width = THUMB_WIDTH;
                        cellCanvas.height = THUMB_HEIGHT;
                        
                        // Desenha apenas se houver conteúdo
                        if (layerData && layerData.history[layerData.historyIndex]) {
                            // Usamos createImageBitmap para performance, mas cuidado com async em loops grandes
                            // Para simplificar e garantir sincronia visual imediata, usamos putImageData num canvas temp e drawImage
                            const imgData = layerData.history[layerData.historyIndex];
                            
                            // Verifica se não está vazio (transparente) para economizar processamento
                            // (Opcional, mas bom para performance)
                            
                            thumbResizerCtx.clearRect(0, 0, 54, 30);
                            // Desenha em escala reduzida (aproximada)
                            // Como não podemos desenhar ImageData com escala direto, usamos o bitmap
                            createImageBitmap(imgData).then(bmp => {
                                const ctx = cellCanvas.getContext('2d');
                                ctx.drawImage(bmp, 0, 0, cellCanvas.width, cellCanvas.height);
                                bmp.close();
                            });
                        }

                        cell.appendChild(cellCanvas);

                        // Evento de Clique na Célula
                        cell.addEventListener('pointerdown', (e) => {
                            if (selectionCanvas) applyAndSaveTransformation();
                            
                            // Lógica de seleção (Shift/Ctrl)
                            if (e.shiftKey) {
                                const start = Math.min(currentFrameIndex, f);
                                const end = Math.max(currentFrameIndex, f);
                                selectedFrameIndices.clear();
                                for(let i=start; i<=end; i++) selectedFrameIndices.add(i);
                            } else if (e.ctrlKey || e.metaKey) {
                                if (selectedFrameIndices.has(f)) selectedFrameIndices.delete(f);
                                else selectedFrameIndices.add(f);
                            } else {
                                selectedFrameIndices.clear();
                                selectedFrameIndices.add(f);
                            }

                            currentFrameIndex = f;
                            currentLayerIndex = l;
                            preferredLayerIndex = l;
                            
                            updateUI(); // Atualiza a grade inteira para refletir seleção
                            renderCanvas();
                            updateLayerPanelAndHistoryIndicators();
                        });

                        row.appendChild(cell);
                    }
                    timelineFrames.appendChild(row);
                }

                // Atualiza painel lateral e histórico
                updateLayerPanelAndHistoryIndicators();
                updateTimelineWidths(); // Garante que a largura do container esteja correta
            }

            // Função matemática para calcular a matriz de transformação de um triângulo
            function drawTexturedTriangle(ctx, img, x0, y0, x1, y1, x2, y2, u0, v0, u1, v1, u2, v2) {
                ctx.save();
                ctx.beginPath();
                
                // --- CORREÇÃO DO RETALHAMENTO (Aumentar Preenchimento) ---
                // A ideia é expandir ligeiramente o caminho de recorte (clip) do triângulo
                // para que ele se sobreponha minimamente aos seus vizinhos, cobrindo as
                // pequenas lacunas que causam o efeito de "retalhamento".
                
                // 1. Calcula o centro (centroide) do triângulo.
                const cx = (x0 + x1 + x2) / 3;
                const cy = (y0 + y1 + y2) / 3;

                // 2. Define um fator de escala dinâmico para expandir o triângulo.
                // Calcula a distância máxima do centro para um vértice.
                const dist = Math.max(Math.hypot(x0-cx, y0-cy), Math.hypot(x1-cx, y1-cy), Math.hypot(x2-cx, y2-cy));
                
                // Garante uma sobreposição de ~1.5 pixels independentemente do tamanho do triângulo.
                // Isso resolve o problema de "quadriculado" (frestas) em zooms altos ou malhas densas.
                const scaleFactor = 1 + (0.01 / (dist || 1));

                // 3. Desenha o caminho do triângulo expandido para o recorte.
                ctx.moveTo(cx + (x0 - cx) * scaleFactor, cy + (y0 - cy) * scaleFactor);
                ctx.lineTo(cx + (x1 - cx) * scaleFactor, cy + (y1 - cy) * scaleFactor);
                ctx.lineTo(cx + (x2 - cx) * scaleFactor, cy + (y2 - cy) * scaleFactor);
                
                ctx.closePath();
                
                // Aplicamos o recorte na área expandida
                ctx.clip();

                // --- DESENHO DA TEXTURA ---
                // A matriz de transformação ainda usa as coordenadas originais dos vértices
                // para garantir que a textura em si não seja esticada, apenas a área
                // visível (o recorte) é que foi expandida.
                
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';

                const det = (u1 - u0) * (v2 - v0) - (u2 - u0) * (v1 - v0);
                if (det === 0) { ctx.restore(); return; }

                const a = ((x1 - x0) * (v2 - v0) - (x2 - x0) * (v1 - v0)) / det;
                const b = ((y1 - y0) * (v2 - v0) - (y2 - y0) * (v1 - v0)) / det;
                const c = ((x2 - x0) * (u1 - u0) - (x1 - x0) * (u2 - u0)) / det;
                const d = ((y2 - y0) * (u1 - u0) - (y1 - y0) * (u2 - u0)) / det;
                const e = x0 - a * u0 - c * v0;
                const f = y0 - b * u0 - d * v0;

                ctx.transform(a, b, c, d, e, f);
                ctx.drawImage(img, 0, 0);
                ctx.restore();
            }

            // --- NOVA FUNÇÃO: Desenha uma imagem com uma sobreposição de cor ---
            function drawTintedImage(sourceCanvas, destContext, tintColor) {
                // 1. Desenha a imagem original no contexto de destino
                destContext.drawImage(sourceCanvas, 0, 0);

                // 2. Usa 'source-in' para garantir que a cor só seja aplicada
                //    onde já existem pixels da imagem original.
                destContext.globalCompositeOperation = 'source-in';

                // 3. Preenche a área com a cor de tonalidade desejada
                destContext.fillStyle = tintColor;
                destContext.fillRect(0, 0, destContext.canvas.width, destContext.canvas.height);

                // 4. Restaura a operação de composição padrão para desenhos futuros
                destContext.globalCompositeOperation = 'source-over';
            }

            function renderWarpedSelection(ctx, grid, sourceCanvas, drawGuides = true) {
                if (!grid || grid.length < 2) return;
                
                const rows = grid.length - 1;
                const cols = grid[0].length - 1;
                const cellW = sourceCanvas.width / cols;
                const cellH = sourceCanvas.height / rows;

                // 1. DESENHO DA IMAGEM (TEXTURA)
                for (let i = 0; i < rows; i++) {
                    for (let j = 0; j < cols; j++) {
                        const p1 = grid[i][j];
                        const p2 = grid[i][j + 1];
                        const p3 = grid[i + 1][j + 1];
                        const p4 = grid[i + 1][j];

                        // Coordenadas da textura original (UV)
                        const u1 = j * cellW, v1 = i * cellH;
                        const u2 = (j + 1) * cellW, v2 = i * cellH;
                        const u3 = (j + 1) * cellW, v3 = (i + 1) * cellH;
                        const u4 = j * cellW, v4 = (i + 1) * cellH;

                        // Triângulo 1: Top-Left, Top-Right, Bottom-Right
                        drawTexturedTriangle(ctx, sourceCanvas, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y, u1, v1, u2, v2, u3, v3);
                        
                        // Triângulo 2: Top-Left, Bottom-Right, Bottom-Left
                        drawTexturedTriangle(ctx, sourceCanvas, p1.x, p1.y, p3.x, p3.y, p4.x, p4.y, u1, v1, u3, v3, u4, v4);
                    }
                }

                // 2. DESENHO DA INTERFACE (SÓ SE DRAWGUIDES FOR TRUE)
                if (drawGuides) {
                    ctx.save();
                    ctx.globalAlpha = 0.1; // Opacidade ajustada para 0.1
                    ctx.lineWidth = 1;
                    ctx.strokeStyle = 'rgba(0, 255, 255, 0.6)'; 
                    ctx.fillStyle = 'rgba(0, 255, 255, 0.6)';
                    
                    for (let row = 0; row < grid.length; row++) {
                        for (let col = 0; col < grid[row].length; col++) {
                            const point = grid[row][col];
                            
                            // Desenha linhas
                            if (col < grid[row].length - 1) {
                                const pNext = grid[row][col + 1];
                                ctx.beginPath(); ctx.moveTo(point.x, point.y); ctx.lineTo(pNext.x, pNext.y); ctx.stroke();
                            }
                            if (row < grid.length - 1) {
                                const pDown = grid[row + 1][col];
                                ctx.beginPath(); ctx.moveTo(point.x, point.y); ctx.lineTo(pDown.x, pDown.y); ctx.stroke();
                            }
    
                            // Desenha Pontos (Nós)
                            ctx.beginPath();
                            ctx.arc(point.x, point.y, 4, 0, Math.PI * 2); // Pontos menores para não poluir
                            ctx.fill();
                            
                            // Destaque no ponto ativo
                            if(activeWarpNode && activeWarpNode.r === row && activeWarpNode.c === col){
                                ctx.save();
                                ctx.fillStyle = '#ff00ff'; 
                                ctx.beginPath();
                                ctx.arc(point.x, point.y, 6, 0, Math.PI * 2);
                                ctx.fill();
                                ctx.restore();
                            }
                        }
                    }
                    ctx.restore(); // <-- CORREÇÃO ADICIONADA AQUI
                }
            }

            function drawSkeleton(ctx) {
                const currentFrame = timelineFramesData[currentFrameIndex];
                if (!currentFrame || !currentFrame.bones) return;

                const bones = currentFrame.bones;

                ctx.save();
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                // 1. Desenhar Conexões (Ossos)
                bones.forEach(bone => {
                    if (bone.parentIndex !== -1 && bones[bone.parentIndex]) {
                        const parent = bones[bone.parentIndex];
                        ctx.beginPath();
                        ctx.moveTo(parent.x, parent.y);
                        ctx.lineTo(bone.x, bone.y);
                        
                        // Gradiente para dar volume visual ao osso
                        ctx.lineWidth = 6; // Borda externa
                        ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)'; 
                        ctx.stroke();
                        
                        ctx.lineWidth = 3; // Linha interna
                        ctx.strokeStyle = '#ffff00'; // Amarelo
                        ctx.stroke();
                    }
                });

                // 2. Desenhar Juntas (Joints)
                bones.forEach((bone, index) => {
                    ctx.beginPath();
                    ctx.arc(bone.x, bone.y, 6, 0, Math.PI * 2);
                    
                    // Cor diferente se estiver selecionado
                    if (index === selectedBoneIndex) {
                        ctx.fillStyle = '#ff00ff'; // Magenta para selecionado
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = 'white';
                    } else {
                        ctx.fillStyle = '#00ffff'; // Ciano para normal
                        ctx.shadowBlur = 0;
                    }
                    
                    ctx.fill();
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                });

                ctx.restore();
            }

           function renderCanvas(skipLayerIndex = -1) {
                // Limpa os canvas
                ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                onionCtx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                // --- PROTEÇÃO DE ÍNDICE ---
                // Se o índice for inválido, volta para 0 para não ficar tela branca
                if (!timelineFramesData[currentFrameIndex]) {
                    currentFrameIndex = 0;
                }
                const currentFrame = timelineFramesData[currentFrameIndex];
                
                // Se mesmo assim não tiver frame (projeto vazio), desenha fundo branco e sai
                if (!currentFrame) {
                    return;
                }
                
            
                // 1. Desenha Onion Skin (se ativo)
                if (onionSkinning && currentFrameIndex > 0) {
                    const prevFrame = timelineFramesData[currentFrameIndex - 1];
                    const onionCompositeCanvas = document.createElement('canvas');
                    onionCompositeCanvas.width = CANVAS_WIDTH;
                    onionCompositeCanvas.height = CANVAS_HEIGHT;
                    const onionCompositeCtx = onionCompositeCanvas.getContext('2d');
                    
                    // ALTERAÇÃO: Onion Skin apenas para a camada ativa
                    const layer = prevFrame.layers[currentLayerIndex];
                    if (layer && layer.visible && !layer.isBackground) {
                        const prevFrameData = layer.history[layer.historyIndex];
                        sharedTempLayerCtx.putImageData(prevFrameData, 0, 0);
                        onionCompositeCtx.globalAlpha = layer.opacity;
                        onionCompositeCtx.drawImage(sharedTempLayerCanvas, 0, 0);
                    }
                    drawTintedImage(onionCompositeCanvas, onionCtx, `rgba(255, 100, 100, ${onionOpacity})`);
                }
                
                // 2. Desenha as Camadas do Frame Atual
                // OTIMIZAÇÃO: Usa o canvas compartilhado em vez de criar um novo
                const tempRenderCtx = sharedTempLayerCanvas.getContext('2d');
                
                for (const [index, layer] of currentFrame.layers.entries()) {
                    if(index === skipLayerIndex) continue;
            
                    if (layer.visible) {
                        const imageDataToDraw = layer.history[layer.historyIndex];
                        if (imageDataToDraw) {
                            tempRenderCtx.putImageData(imageDataToDraw, 0, 0);
                            ctx.globalAlpha = layer.opacity;
                            ctx.drawImage(sharedTempLayerCanvas, 0, 0);
                            // Não precisamos limpar o sharedTempLayerCanvas pois putImageData sobrescreve
                        }
                    }
                }
                ctx.globalAlpha = 1.0;
            
                // 3. Lógica de Desenho da Seleção / Warp
                if (selectionCanvas) {
                    // MODO PUPPET (DEFORMAÇÃO)
                    if (currentTool === 'puppet' && warpGrid) {
                        // A. Desenha a imagem deformada
                        renderWarpedSelection(ctx, warpGrid, selectionCanvas, true);
            
                        // B. Desenha o contorno (Outline) conectando os pinos
                        if (puppetPins.length > 1) {
                            ctx.save();
                            ctx.beginPath();
                            ctx.lineWidth = 2;
                            ctx.strokeStyle = '#00ffff';
                            ctx.setLineDash([5, 5]);
                            
                            ctx.moveTo(puppetPins[0].x, puppetPins[0].y);
                            for (let i = 1; i < puppetPins.length; i++) {
                                ctx.lineTo(puppetPins[i].x, puppetPins[i].y);
                            }
                            ctx.closePath();
                            ctx.stroke();
                            ctx.restore();
                        }

                        // C. Desenha os pinos da marionete por cima da malha deformada
                        ctx.save();
                        puppetPins.forEach((pin, index) => {
                            ctx.beginPath();
                            ctx.arc(pin.x, pin.y, 8, 0, Math.PI * 2);
                            if (activeWarpNode && activeWarpNode.type === 'puppet' && activeWarpNode.puppetIndex === -1 && activeWarpNode.pinIndex === index) {
                                // Pino ativo (verde) com 100% de opacidade.
                                ctx.fillStyle = 'rgba(0, 255, 0, 1.0)';
                            } else {
                                // Pinos de controle (magenta) com 100% de opacidade.
                                ctx.fillStyle = 'rgba(255, 0, 255, 1.0)';
                            }
                            ctx.fill();
                        });
                        ctx.restore();

                    } else {
                        // MODO SELEÇÃO PADRÃO (Se não for warp, desenha a caixa normal)
                        drawTransformedSelection();
                    }
                }

                // --- DESENHA MÚLTIPLOS PUPPETS ---
                if (puppets.length > 0) {
                    puppets.forEach((p, pIdx) => {
                        // A. Desenha a imagem deformada
                        renderWarpedSelection(ctx, p.grid, p.canvas, true);

                        // B. Desenha o contorno
                        if (p.pins.length > 1) {
                            ctx.save();
                            ctx.beginPath();
                            ctx.lineWidth = 2;
                            ctx.strokeStyle = '#00ffff';
                            ctx.setLineDash([5, 5]);
                            ctx.moveTo(p.pins[0].x, p.pins[0].y);
                            for (let i = 1; i < p.pins.length; i++) ctx.lineTo(p.pins[i].x, p.pins[i].y);
                            ctx.closePath();
                            ctx.stroke();
                            ctx.restore();
                        }

                        // C. Desenha os pinos
                        ctx.save();
                        p.pins.forEach((pin, pinIdx) => {
                            ctx.beginPath();
                            ctx.arc(pin.x, pin.y, 8, 0, Math.PI * 2);
                            if (activeWarpNode && activeWarpNode.type === 'puppet' && activeWarpNode.puppetIndex === pIdx && activeWarpNode.pinIndex === pinIdx) {
                                ctx.fillStyle = 'rgba(0, 255, 0, 1.0)';
                            } else {
                                ctx.fillStyle = 'rgba(255, 0, 255, 1.0)';
                            }
                            ctx.fill();
                        });
                        ctx.restore();
                    });
                }
                
                // 4. Desenha o caminho da seleção enquanto você está criando ela
                if (isSelecting && selectionPath.length > 0) {
                    ctx.save();
                    ctx.beginPath();
                    ctx.moveTo(selectionPath[0].x, selectionPath[0].y);
                    for (let i = 1; i < selectionPath.length; i++) {
                        ctx.lineTo(selectionPath[i].x, selectionPath[i].y);
                    }
                    ctx.setLineDash([4, 4]);
                    ctx.strokeStyle = 'rgba(0, 100, 255, 0.8)';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    ctx.restore();
                }
                
                // 5. Desenha os pinos da marionete durante a criação
                if (currentTool === 'puppet' && puppetPins.length > 0 && !selectionCanvas) {
                    ctx.save();
                    // CORREÇÃO: Garante que os pinos de criação (quadrados) e as linhas
                    // sejam desenhados com 100% de opacidade.
                    ctx.strokeStyle = 'rgba(255, 0, 255, 1.0)'; // Linhas
                    ctx.fillStyle = 'rgba(255, 0, 255, 1.0)';   // Quadrados dos pinos
                    ctx.lineWidth = 2;
                    
                    if (isDrawingPuppetLasso) {
                        ctx.setLineDash([]); // Linha sólida para o laço
                    } else {
                        ctx.setLineDash([5, 5]);
                    }

                    ctx.beginPath();
                    ctx.moveTo(puppetPins[0].x, puppetPins[0].y);
                    puppetPins.forEach((pin, i) => {
                        if (i > 0) ctx.lineTo(pin.x, pin.y);
                        if (!isDrawingPuppetLasso) ctx.fillRect(pin.x - 4, pin.y - 4, 8, 8); // Desenha um quadrado para cada pino
                    });
                    ctx.stroke(); // Desenha as linhas conectando os pinos
                    ctx.restore();
                }
            }

            function getMousePos(canvas, evt) {
                // Pega o tamanho visual atual e a posição na tela (já considerando o Zoom e Pan do CSS)
                const rect = canvas.getBoundingClientRect();
                
                // Calcula a escala: "Quantos pixels internos do canvas valem 1 pixel da tela?"
                // Se o canvas tem 1920px mas está sendo exibido com 960px de largura, o scaleX será 2.
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;

                return {
                    // Multiplicamos a posição do mouse pela escala para encontrar a coordenada real
                    x: (evt.clientX - rect.left) * scaleX,
                    y: (evt.clientY - rect.top) * scaleY
                };
            }

            function saveHistoryState(imageData) {
                const currentFrameLayers = timelineFramesData[currentFrameIndex].layers;
                if (!currentFrameLayers[currentLayerIndex]) return;

                const currentLayer = currentFrameLayers[currentLayerIndex];
                
                // CORREÇÃO: Se o histórico foi desfeito (undo), e uma nova ação é feita,
                // todos os estados "futuros" (redo) devem ser descartados para evitar
                // inconsistências e ramificações de histórico inválidas.
                if (currentLayer.historyIndex < currentLayer.history.length - 1) {
                    currentLayer.history.splice(currentLayer.historyIndex + 1);
                }
                
                // Adiciona o novo estado e gerencia o tamanho máximo do histórico.
                currentLayer.history.push(imageData);
                
                if (currentLayer.history.length > MAX_HISTORY_STATES) {
                    currentLayer.history.shift();
                }
                currentLayer.historyIndex = currentLayer.history.length - 1;
            }

            function draw(e, dCtx) {
                if (!isDrawing || !dCtx) return;
                const pos = getMousePos(mainCanvas, e);
                const x = pos.x, y = pos.y;
                const pressure = (typeof e.pressure !== 'undefined' && e.pressure !== 0) ? e.pressure : ((typeof e.force !== 'undefined') ? e.force : 1.0);
                
                // Dinâmica de Tamanho baseada na pressão
                let sizePressureFactor = 1;
                let effectiveSize = currentBrush.size;

                if (currentBrush.type === 'pencil') {
                    sizePressureFactor = 0.5 + 0.5 * pressure; // Lápis varia menos
                    effectiveSize = currentBrush.size + 7; // Tamanho 1 visualmente igual ao 8 antigo
                } else if (currentBrush.type === 'normal') {
                    sizePressureFactor = 0.2 + 0.8 * pressure; // Pincel varia muito
                }
                
                const localBrushSize = Math.max(1, effectiveSize * sizePressureFactor);
                
                // Configuração de Espaçamento (Spacing) - Segredo do Procreate
                // Define a cada quantos pixels o pincel "carimba" a textura
                const config = brushesConfig[currentBrush.type] || brushesConfig.normal;
                const spacing = Math.max(1, localBrushSize * (config.spacing || 0.1));

                // Interpolação Linear (Lerp)
                smoothPointer.x = smoothPointer.x + (x - smoothPointer.x) * SMOOTH_FACTOR;
                smoothPointer.y = smoothPointer.y + (y - smoothPointer.y) * SMOOTH_FACTOR;

                // Use smoothPointer.x e smoothPointer.y para desenhar
                const dist = Math.hypot(smoothPointer.x - lastX, smoothPointer.y - lastY);
                const angle = Math.atan2(smoothPointer.y - lastY, smoothPointer.x - lastX);

                // Loop otimizado com espaçamento
                for (let i = 0; i < dist; i += spacing) {
                    const px = lastX + Math.cos(angle) * i;
                    const py = lastY + Math.sin(angle) * i;

                    dCtx.globalCompositeOperation = 'source-over';
                    // Desenha a textura do pincel (cacheada e colorida)
                    // A opacidade é aplicada ao renderizar o strokeCanvas, então aqui usamos 1.0
                    dCtx.globalAlpha = 1.0;
                    
                    // Centraliza a textura no ponto para construir a forma do traço
                    dCtx.drawImage(activeBrushCanvas, px - localBrushSize/2, py - localBrushSize/2, localBrushSize, localBrushSize);
                }

                // Atualiza lastX/Y com o valor suavizado
                [lastX, lastY] = [smoothPointer.x, smoothPointer.y];
            }

            // Helper para calcular o tempo exato de início de um frame (em segundos)
            function getFrameStartTime(frameIndex) {
                let totalDuration = 0;
                for (let i = 0; i < frameIndex; i++) {
                    totalDuration += (timelineFramesData[i].duration || 1);
                }
                return totalDuration / frameRate;
            }

            function animate() {
                // 1. Solicita o próximo frame
                animationId = requestAnimationFrame(animate);

                const now = performance.now();
                let elapsed = now - lastFrameTime;
                
                // --- PROTEÇÃO ANTI-TRAVAMENTO (NOVO) ---
                // Se o atraso for maior que 0.5 segundos (ex: troca de aba ou lag), 
                // força o tempo a se ajustar e não tenta recuperar os frames perdidos.
                if (elapsed > 3000) {
                    elapsed = 0;
                    lastFrameTime = now;
                }
                // ---------------------------------------

                if (isPlaying && timelineFramesData.length > 0) {
                    // --- 3. HARDWARE AUDIO SYNC (MASTER CLOCK) ---
                    if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    
                    // Use Audio Hardware Clock instead of CPU Clock
                    const currentTime = audioContext.currentTime;
                    
                    // Calculate exact frame based on audio time
                    const elapsed = currentTime - playbackStartTime;
                    let targetFrame = Math.floor(elapsed * frameRate);
                    
                    // Loop Logic
                    let totalFrames = 0;
                    // Calculate total frames considering duration
                    // For optimization, we assume simple indexing for now, but ideally we sum durations
                    const totalDurationFrames = timelineFramesData.reduce((acc, f) => acc + (f.duration || 1), 0);

                    if (targetFrame >= totalDurationFrames) {
                        // Loop
                        playbackStartTime = currentTime;
                        targetFrame = 0;
                        stopAllAudio(); // Resync audio
                    }

                    // Frame Dropping / Skipping Logic
                    const oldFrameIndex = currentFrameIndex; 
                    
                    // Map linear targetFrame to variable duration timeline
                    // (Simplified for this snippet: assumes 1:1 mapping if duration is 1, 
                    // real implementation would map targetFrame -> specific frame index)
                    let mappedIndex = 0;
                    let frameCounter = 0;
                    for(let i=0; i<timelineFramesData.length; i++) {
                        const dur = timelineFramesData[i].duration || 1;
                        if (targetFrame < frameCounter + dur) {
                            mappedIndex = i;
                            break;
                        }
                        frameCounter += dur;
                        mappedIndex = i; // Clamp to last
                    }
                    
                    currentFrameIndex = mappedIndex;

                    // Sync Audio
                    playAudioForCurrentTime(elapsed);

                    if (currentFrameIndex !== oldFrameIndex) {
                        if (isPlaying) {
                            selectedFrameIndices.clear();
                            selectedFrameIndices.add(currentFrameIndex);
                        }
                        renderCanvas();
                        refreshTimelineSelectionUI();
                    }
                } else {
                    lastFrameTime = now;
                }
            }
            
            function stopAllAudio() {
                activeAudioSources.forEach(s => {
                    try { s.source.stop(); } catch(e) {}
                });
                activeAudioSources = [];
            }

            function playAudioForCurrentTime(currentTime) {
                if(!audioContext) return;

                activeAudioSources = activeAudioSources.filter(s => {
                    // Mantém apenas fontes ativas. A limpeza pesada é feita no stopAllAudio()
                    return true;
                });

                audioTracks.forEach(track => {
                    const alreadyPlaying = activeAudioSources.some(s => s.id === track.id);
                    const clipStartTime = track.timelineStart;
                    const clipDuration = track.trimDuration;
                    const clipEndTime = clipStartTime + clipDuration;
                    
                    // Verifica se estamos DENTRO do clipe (permite tocar do meio)
                    const isInside = currentTime >= clipStartTime && currentTime < clipEndTime;

                    if (!alreadyPlaying && isInside) {
                        const source = audioContext.createBufferSource();
                        const bufferToPlay = sliceAudioBuffer(track.originalBuffer, track.trimStart, track.trimDuration);

                        if (bufferToPlay) {
                            source.buffer = bufferToPlay;
                            source.connect(audioContext.destination);
                            
                            // Calcula o ponto exato para começar (offset)
                            const offset = currentTime - clipStartTime;
                            source.start(0, offset);
                            
                            activeAudioSources.push({ id: track.id, source: source, startTime: audioContext.currentTime, duration: track.trimDuration });
                        }
                    }
                });
            }

            function togglePlayState() {
                isPlaying = !isPlaying;
                const playIcon = playPauseBtn.querySelector('#play-icon');
                const pauseIcon = playPauseBtn.querySelector('#pause-icon');
                
                if (isPlaying) {
                    // --- Iniciando a reprodução ---
                    playIcon.classList.add('hidden');
                    pauseIcon.classList.remove('hidden');
                    
                    // Se já estava no último frame, reseta para -1 para começar do 0
                    if (currentFrameIndex === timelineFramesData.length - 1) {
                        currentFrameIndex = 0;
                        frameHoldCounter = -1;
                    }
                
                    // Garante que o AudioContext esteja ativo (corrige o problema de não tocar de primeira)
                    if (audioContext && audioContext.state === 'suspended') {
                        audioContext.resume();
                    }

                    // Set the Master Clock Start Time
                    playbackStartTime = audioContext.currentTime - (getFrameStartTime(currentFrameIndex));
                    stopAllAudio();

                } else {
                    // --- Pausando a reprodução ---
                    playIcon.classList.remove('hidden');
                    pauseIcon.classList.add('hidden');
                    stopAllAudio();

                    // *** ADIÇÃO IMPORTANTE ***
                    // Garante que o índice não seja -1 se o usuário parar imediatamente
                    if (currentFrameIndex < 0) {
                        currentFrameIndex = 0;
                    }
                    
                    // Agora que paramos, chamamos a função 'pesada' (updateUI)
                    // para sincronizar o painel de camadas e os destaques da timeline.
                    updateUI();
                }
            }

            // --- Funções da Ferramenta de Seleção ---

            function getHandles() {
                const { x, y, width, height, rotation } = selectionTransform;
                const cx = x + width / 2;
                const cy = y + height / 2;

                const handles = {
                    tl: { x: x, y: y },
                    tr: { x: x + width, y: y },
                    bl: { x: x, y: y + height },
                    br: { x: x + width, y: y + height },
                    rot: { x: x + width / 2, y: y - 20 }
                };

                for (let key in handles) {
                    const handle = handles[key];
                    const dx = handle.x - cx;
                    const dy = handle.y - cy;
                    const rotatedX = cx + dx * Math.cos(rotation) - dy * Math.sin(rotation);
                    const rotatedY = cy + dx * Math.sin(rotation) + dy * Math.cos(rotation);
                    handles[key] = { x: rotatedX, y: rotatedY };
                }
                return handles;
            }

            function getHandleAt(pos) {
                const handles = getHandles();
                for (let key in handles) {
                    const handle = handles[key];
                    if (Math.hypot(pos.x - handle.x, pos.y - handle.y) < HANDLE_SIZE) {
                        return key;
                    }
                }
                const { x, y, width, height, rotation } = selectionTransform;
                const cx = x + width / 2;
                const cy = y + height / 2;
                const dx = pos.x - cx;
                const dy = pos.y - cy;
                const localX = dx * Math.cos(-rotation) - dy * Math.sin(-rotation) + width / 2;
                const localY = dx * Math.sin(-rotation) + dy * Math.cos(-rotation) + height / 2;

                if(localX >= 0 && localX <= width && localY >=0 && localY <= height) {
                    return 'move';
                }

                return null;
            }
            
            function drawTransformedSelection() {
                const { x, y, width, height, rotation } = selectionTransform;
                const cx = x + width / 2;
                const cy = y + height / 2;

                ctx.save();
                ctx.imageSmoothingQuality = 'high';
                ctx.translate(cx, cy);
                ctx.rotate(rotation);
                ctx.drawImage(selectionCanvas, -width / 2, -height / 2, width, height);

                // Draw bounding box
                ctx.strokeStyle = '#0066ff';
                ctx.setLineDash([4, 4]);
                ctx.strokeRect(-width / 2, -height / 2, width, height);
                ctx.setLineDash([]);
                ctx.restore();

                // Draw handles
                const handles = getHandles();
                ctx.fillStyle = '#fff';
                ctx.strokeStyle = '#0066ff';
                for (let key in handles) {
                    const handle = handles[key];
                    ctx.beginPath();
                    if (key === 'rot') {
                        ctx.arc(handle.x, handle.y, HANDLE_SIZE / 2, 0, Math.PI * 2);
                    } else {
                        ctx.rect(handle.x - HANDLE_SIZE / 2, handle.y - HANDLE_SIZE / 2, HANDLE_SIZE, HANDLE_SIZE);
                    }
                    ctx.fill();
                    ctx.stroke();
                }
            }

            // --- NOVA FUNÇÃO DE RENDERIZAÇÃO AO VIVO ---
            // Esta função compõe o resultado final na tela enquanto você desenha.
            function renderLiveStroke() {
                const currentLayer = timelineFramesData[currentFrameIndex].layers[currentLayerIndex];
                if (!currentLayer) return;

                // 1. Limpa o canvas principal
                ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                // 2. Desenha o fundo em cache (camadas abaixo)
                ctx.drawImage(drawingBackgroundCanvas, 0, 0);

                // 3. Composição da camada atual + traço em um buffer separado
                // Usamos o sharedTempLayerCanvas para evitar criar novos canvas
                sharedTempLayerCtx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                
                // Desenha o estado original da camada
                sharedTempLayerCtx.drawImage(tempDrawCanvas, 0, 0);
                
                // Aplica o traço (Brush ou Eraser) no buffer
                sharedTempLayerCtx.globalAlpha = currentBrush.opacity;
                if (currentTool === 'eraser') {
                    sharedTempLayerCtx.globalCompositeOperation = 'destination-out';
                } else {
                    sharedTempLayerCtx.globalCompositeOperation = 'source-over';
                }
                sharedTempLayerCtx.drawImage(strokeCanvas, 0, 0);
                
                // Restaura o estado do buffer
                sharedTempLayerCtx.globalAlpha = 1.0;
                sharedTempLayerCtx.globalCompositeOperation = 'source-over';

                // 4. Desenha a camada composta no canvas principal
                ctx.globalAlpha = currentLayer.opacity;
                ctx.globalCompositeOperation = currentLayer.blendMode || 'source-over';
                ctx.drawImage(sharedTempLayerCanvas, 0, 0);

                // 5. Reseta o estado do canvas principal
                ctx.globalAlpha = 1.0;
                ctx.globalCompositeOperation = 'source-over';
            }


            function finalizeAndCaptureSelection() {
                if (selectionPath.length < 3) {
                    selectionPath = [];
                    return;
                }

                const currentLayers = timelineFramesData[currentFrameIndex].layers;
                const frame = currentLayers[currentLayerIndex];
                const sourceImageData = frame.history[frame.historyIndex];

                const sourceCanvas = document.createElement('canvas');
                sourceCanvas.width = CANVAS_WIDTH;
                sourceCanvas.height = CANVAS_HEIGHT;
                sourceCanvas.getContext('2d').putImageData(sourceImageData, 0, 0);

                let minX = CANVAS_WIDTH, minY = CANVAS_HEIGHT, maxX = 0, maxY = 0;
                selectionPath.forEach(p => {
                    minX = Math.min(minX, p.x); minY = Math.min(minY, p.y);
                    maxX = Math.max(maxX, p.x); maxY = Math.max(maxY, p.y);
                });
                const bounds = { x: Math.floor(minX), y: Math.floor(minY), width: Math.ceil(maxX - minX), height: Math.ceil(maxY - minY)};
                
                if (bounds.width <= 0 || bounds.height <= 0) {
                    selectionPath = []; return;
                }
                
                selectionCanvas = document.createElement('canvas');
                selectionCanvas.width = bounds.width;
                selectionCanvas.height = bounds.height;
                const selCtx = selectionCanvas.getContext('2d');
                
                selCtx.beginPath();
                selCtx.moveTo(selectionPath[0].x - bounds.x, selectionPath[0].y - bounds.y);
                for(let i=1; i<selectionPath.length; i++) {
                    selCtx.lineTo(selectionPath[i].x - bounds.x, selectionPath[i].y - bounds.y);
                }
                selCtx.closePath();
                selCtx.clip();
                selCtx.drawImage(sourceCanvas, -bounds.x, -bounds.y);
                
                selectionTransform = { x: bounds.x, y: bounds.y, width: bounds.width, height: bounds.height, rotation: 0 };
                
                const mainLayerCtx = sourceCanvas.getContext('2d');
                mainLayerCtx.save();
                mainLayerCtx.globalCompositeOperation = 'destination-out';
                mainLayerCtx.beginPath();
                mainLayerCtx.moveTo(selectionPath[0].x, selectionPath[0].y);
                for(let i=1; i<selectionPath.length; i++) mainLayerCtx.lineTo(selectionPath[i].x, selectionPath[i].y);
                mainLayerCtx.closePath();
                mainLayerCtx.fill();
                // CORREÇÃO: Adiciona um traço para limpar resíduos nas bordas (sombra/fantasma)
                mainLayerCtx.lineWidth = 1.5;
                mainLayerCtx.strokeStyle = '#000000';
                mainLayerCtx.stroke();
                mainLayerCtx.restore();

                // Salva o estado imediatamente para evitar delay visual
                saveHistoryState(mainLayerCtx.getImageData(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT));
                
                selectionPath = [];
                renderCanvas();
                updateCurrentFrameThumbnail(); 
                updateLayerPanelAndHistoryIndicators(); // Update layers list and undo/redo buttons
            }

            // NOVA FUNÇÃO DEDICADA: Aplica a transformação e salva no histórico.
           // CORREÇÃO DO BUG DE TRAVAMENTO NO PUPPET INCOMPLETO
            function applyAndSaveTransformation() {
                // 1. Cenário: Puppet incompleto ou sem seleção
                // Se não temos seleção nem puppets, sai.
                if (!selectionCanvas && puppets.length === 0) {
                    // AQUI ESTAVA O BUG: Antes, ele dava 'return' sem limpar.
                    // AGORA: Forçamos a limpeza antes de sair.
                    resetTransformationState(); 
                    return;
                }

                // 2. Cenário: Seleção válida (Salvar no histórico)
                const currentLayers = timelineFramesData[currentFrameIndex].layers;
                const frame = currentLayers[currentLayerIndex];
                const targetImageData = frame.history[frame.historyIndex];

                // BLOQUEIO DE EDIÇÃO NO BACKGROUND
                if (frame.isBackground) {
                    showMessage('Aviso', 'A camada de fundo é bloqueada para edições. Use o seletor de cor na camada para alterá-la.');
                    resetTransformationState();
                    return;
                }

                const finalCanvas = document.createElement('canvas');
                finalCanvas.width = CANVAS_WIDTH;
                finalCanvas.height = CANVAS_HEIGHT;
                const finalCtx = finalCanvas.getContext('2d');
                finalCtx.putImageData(targetImageData, 0, 0);

                // Se a ferramenta puppet estiver ativa com uma grade, renderiza a deformação
                if (currentTool === 'puppet') {
                    if (warpGrid && selectionCanvas) {
                        renderWarpedSelection(finalCtx, warpGrid, selectionCanvas, false);
                    }
                    // Renderiza todos os puppets acumulados
                    puppets.forEach(p => {
                        renderWarpedSelection(finalCtx, p.grid, p.canvas, false);
                    });
                } else {
                    const { x, y, width, height, rotation } = selectionTransform;
                    const cx = x + width / 2;
                    const cy = y + height / 2;
                    finalCtx.save();
                    finalCtx.translate(cx, cy);
                    finalCtx.rotate(rotation);
                    finalCtx.drawImage(selectionCanvas, -width / 2, -height / 2, width, height);
                    finalCtx.restore();
                }

                saveHistoryState(finalCtx.getImageData(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT));

                // 3. Limpeza Final (Sucesso)
                resetTransformationState();

                // Atualizações de UI
                renderCanvas();
                if (currentLayerIndex === 0) { // Background layer
                    timelineFramesData.forEach(frame => frame.isDirty = true);
                    updateUI();
                } else {
                    timelineFramesData[currentFrameIndex].isDirty = true;
                    updateCurrentFrameThumbnail();
                }
            }

         // FUNÇÃO DE LIMPEZA BLINDADA
            function resetTransformationState() {
                // 1. Limpeza de Variáveis
                selectionCanvas = null;
                activeWarpNode = null;
                warpGrid = null;
                puppetPins = []; // Zera os pinos para não desenhar lixo no novo frame
                puppets = []; // Zera os puppets
                activeHandle = null;
                selectionPath = [];
                
                // 2. Reseta estados de interação para evitar loops
                isSelecting = false;
                isDrawingPuppetLasso = false;
                isDrawing = false; 
                activePointerId = null;

                // 3. REMOVE TODOS OS LISTENERS POSSÍVEIS (Crítico para não travar)
                // Removemos todos, mesmo que não estejam ativos, para garantir.
                window.removeEventListener('pointermove', handleDrawMove);
                window.removeEventListener('pointerup', handleDrawEnd);
                window.removeEventListener('pointermove', handlePuppetMove);
                window.removeEventListener('pointerup', handlePuppetUp);
                window.removeEventListener('mousemove', handleDrawMove);
                window.removeEventListener('mouseup', handleDrawEnd);

                // 4. Limpeza de UI
                if (typeof warpGridControls !== 'undefined') {
                    try { warpGridControls.classList.add('hidden'); } catch(e){}
                }
                
                const canvasWrapper = document.getElementById('canvas-wrapper');
                if(canvasWrapper) canvasWrapper.style.cursor = 'crosshair';

                // 5. Redesenha limpo
                renderCanvas(); 
            }

            function createWarpGridFromSelection() {
                if (!selectionCanvas) return;
                const { x, y, width, height } = selectionTransform;
                const density = 10;
                const rows = density;
                const cols = density;
                warpGrid = [];
                for (let i = 0; i <= rows; i++) {
                    const row = [];
                    for (let j = 0; j <= cols; j++) {
                        const point = {
                            x: x + (width * (j / cols)),
                            y: y + (height * (i / rows)),
                            ox: x + (width * (j / cols)), // Posição original
                            oy: y + (height * (i / rows))
                        };
                        row.push(point);
                    }
                    warpGrid.push(row);
                }
            }

            function stampSelection() {
                if (!selectionCanvas) return;
                // CORREÇÃO: A lógica de salvar foi movida para applyAndSaveTransformation.
                // stampSelection agora apenas chama a função correta e simula o stopDrawing para limpar o estado.
                isDrawing = true; // Simula o início de um desenho para que stopDrawing funcione.
                stopDrawing();

                // CORREÇÃO: Limpar o estado da seleção e redesenhar a tela DEPOIS de salvar.
                // Isso garante que a UI da ferramenta (grade, caixa) não seja redesenhada acidentalmente.
                selectionCanvas = null;
                activeWarpNode = null; // Limpa nó ativo
                puppetPins = []; // Limpa os pinos da marionete
                renderCanvas();
                updateCurrentFrameThumbnail(); 
                updateLayerPanelAndHistoryIndicators(); // Update layers list and undo/redo buttons
            }
            
            function floodFill(startX, startY) {
                const currentLayers = timelineFramesData[currentFrameIndex].layers;
                const frame = currentLayers[currentLayerIndex];
                
                if (frame.isBackground) {
                    showMessage('Aviso', 'A camada de fundo é bloqueada. Use o seletor de cor.');
                    return;
                }

                const sourceImageData = frame.history[frame.historyIndex];

                // CORREÇÃO: Garante uma cópia profunda e independente do buffer de dados.
                // O método .slice() cria uma nova cópia do ArrayBuffer, impedindo que o
                // estado anterior do histórico seja modificado acidentalmente.
                const imageData = new ImageData(
                    new Uint8ClampedArray(sourceImageData.data.slice()),
                    sourceImageData.width,
                    sourceImageData.height
                );

                const data = imageData.data;
                const width = CANVAS_WIDTH;
                const height = CANVAS_HEIGHT;

                const hexToRgb = (hex) => {
                    const r = parseInt(hex.slice(1, 3), 16);
                    const g = parseInt(hex.slice(3, 5), 16);
                    const b = parseInt(hex.slice(5, 7), 16);
                    return [r, g, b];
                };

                const [fillR, fillG, fillB] = hexToRgb(currentBrush.color);
                const fillA = 255;

                const startIdx = (startY * width + startX) * 4;
                const startR = data[startIdx];
                const startG = data[startIdx + 1];
                const startB = data[startIdx + 2];
                const startA = data[startIdx + 3];
                
                if (fillR === startR && fillG === startG && fillB === startB && fillA === startA) {
                    return;
                }

                const toleranceThresholdSq = Math.pow(fillTolerance * 2.55, 2);
                const pixelStack = [[startX, startY]];
                const visited = new Uint8Array(width * height);
                visited[startY * width + startX] = 1;

                while (pixelStack.length > 0) {
                    const [x, y] = pixelStack.pop();
                    
                    const currentIdx = (y * width + x) * 4;
                    data[currentIdx] = fillR;
                    data[currentIdx + 1] = fillG;
                    data[currentIdx + 2] = fillB;
                    data[currentIdx + 3] = fillA;

                    const neighbors = [[x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]];
                    for (const [nx, ny] of neighbors) {
                        if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                            const neighborLinearCoord = ny * width + nx;
                            if (visited[neighborLinearCoord]) {
                                continue;
                            }
                            
                            const neighborIdx = neighborLinearCoord * 4;
                            const currentR = data[neighborIdx];
                            const currentG = data[neighborIdx + 1];
                            const currentB = data[neighborIdx + 2];
                            const currentA = data[neighborIdx + 3];

                            const rDiff = currentR - startR;
                            const gDiff = currentG - startG;
                            const bDiff = currentB - startB;
                            const aDiff = currentA - startA;
                            
                            const colorDistanceSq = rDiff * rDiff + gDiff * gDiff + bDiff * bDiff + aDiff * aDiff;

                            if (colorDistanceSq <= toleranceThresholdSq) {
                                pixelStack.push([nx, ny]);
                                visited[neighborLinearCoord] = 1;
                            }
                        }
                    }
                }

                saveHistoryState(imageData);
                renderCanvas();
                updateLayerPanelAndHistoryIndicators();

                if (currentLayerIndex === 0) { // Background layer
                    timelineFramesData.forEach(frame => frame.isDirty = true);
                    updateUI();
                } else {
                    timelineFramesData[currentFrameIndex].isDirty = true;
                    if ('requestIdleCallback' in window) {
                        requestIdleCallback(updateCurrentFrameThumbnail);
                    } else {
                        setTimeout(updateCurrentFrameThumbnail, 50); // Fallback
                    }
                }
            }


            // --- Event Handlers ---
            let activePointerId = null; // Para rastrear qual dedo/caneta está desenhando

            // --- LÓGICA FINAL DA FERRAMENTA DE MARIONETE ---
            const handlePuppetStart = (pos) => {
                // 1. Verifica se clicou em um PINO existente (Prioridade 1)
                for (let i = 0; i < puppets.length; i++) {
                    const p = puppets[i];
                    for (let j = 0; j < p.pins.length; j++) {
                        if (Math.hypot(pos.x - p.pins[j].x, pos.y - p.pins[j].y) < 15) {
                            activeWarpNode = { type: 'puppet', puppetIndex: i, pinIndex: j };
                            window.addEventListener('pointermove', handlePuppetMove);
                            window.addEventListener('pointerup', handlePuppetUp);
                            return;
                        }
                    }
                }

                // 2. Verifica se clicou em um PINO da seleção ativa (Prioridade 1.5)
                if (selectionCanvas && warpGrid) {
                     for (let i = 0; i < puppetPins.length; i++) {
                        if (Math.hypot(pos.x - puppetPins[i].x, pos.y - puppetPins[i].y) < 15) {
                            activeWarpNode = { type: 'puppet', puppetIndex: -1, pinIndex: i }; // -1 indica puppet em criação/único
                            window.addEventListener('pointermove', handlePuppetMove);
                            window.addEventListener('pointerup', handlePuppetUp);
                            return;
                        }
                    }
                }

                // 3. Verifica se clicou na MALHA (Mesh) para deformação livre (Prioridade 2)
                let closestGridPoint = null;
                let minDist = 100; // Raio de detecção
                let hitPuppetIndex = -2; // -2: nenhum, -1: ativo, >=0: lista
                let hitCoords = null;

                // Helper para checar grid
                const checkGrid = (grid, pIdx) => {
                    if (!grid) return;
                    for (let r = 0; r < grid.length; r++) {
                        for (let c = 0; c < grid[r].length; c++) {
                            const pt = grid[r][c];
                            const d = Math.hypot(pos.x - pt.x, pos.y - pt.y);
                            if (d < minDist) {
                                minDist = d;
                                closestGridPoint = pt;
                                hitPuppetIndex = pIdx;
                                hitCoords = { r, c };
                            }
                        }
                    }
                };

                // Checa puppets da lista
                for (let i = 0; i < puppets.length; i++) checkGrid(puppets[i].grid, i);
                // Checa puppet ativo
                if (warpGrid) checkGrid(warpGrid, -1);

                if (closestGridPoint && hitPuppetIndex !== -2) {
                    activeWarpNode = { 
                        type: 'puppet-grid', 
                        puppetIndex: hitPuppetIndex, 
                        r: hitCoords.r, 
                        c: hitCoords.c 
                    };
                    window.addEventListener('pointermove', handlePuppetMove);
                    window.addEventListener('pointerup', handlePuppetUp);
                    return;
                }

                // 4. Se não clicou em nada, inicia CRIAÇÃO FREEHAND (Lasso)
                // Se houver um puppet ativo flutuando, comita ele antes de criar outro
                if (selectionCanvas && warpGrid) {
                    puppets.push({
                            canvas: selectionCanvas,
                            transform: { ...selectionTransform },
                            grid: warpGrid,
                            pins: puppetPins.map(p => ({...p}))
                    });
                    selectionCanvas = null;
                    warpGrid = null;
                    puppetPins = [];
                }

                isDrawingPuppetLasso = true;
                puppetPins = [pos]; // Inicia o caminho
                window.addEventListener('pointermove', handleDrawMove);
                window.addEventListener('pointerup', handleDrawEnd);
                renderCanvas();
            };

            const handleDrawStart = (e) => {
                // A verificação de 'mousedown' foi removida para permitir que a caneta (pointerdown)
                // funcione corretamente com ferramentas de clique único como o balde de tinta.
                e.preventDefault();
            
                const pos = getMousePos(mainCanvas, e);

                // Captura o novo ponteiro como ativo. Isso garante que apenas este ponteiro
                // controlará as ações de desenho, movimento, etc., até que seja liberado.
                activePointerId = e.pointerId;

                // BLOQUEIO DE FERRAMENTAS NO BACKGROUND
                const currentLayer = timelineFramesData[currentFrameIndex].layers[currentLayerIndex];
                if (currentLayer && currentLayer.isBackground && ['brush', 'eraser', 'bucket', 'puppet', 'selection'].includes(currentTool)) {
                    // Permite seleção apenas se já existir uma (para mover/transformar), mas não criar nova
                    if (currentTool !== 'selection' || !selectionCanvas) return;
                }
            
                if (e.pointerId) activePointerId = e.pointerId;
                if (e.type === 'pointerdown') mainCanvas.setPointerCapture(e.pointerId);
            
                // --- CORREÇÃO CRÍTICA DE ESTABILIDADE ---
                // Remove todos os listeners de movimento/soltura anteriores ANTES de adicionar novos.
                // Isso previne "eventos fantasmas" de ferramentas antigas que causavam travamentos
                // ao tentar executar duas ações conflitantes (ex: desenhar e mover seleção) ao mesmo tempo.
                cleanupGlobalPointerListeners();

                // CORREÇÃO: Movido o conta-gotas para o topo para garantir prioridade máxima.
                // Se o conta-gotas estiver ativo, ele deve funcionar independentemente de outras ferramentas.
                if (currentTool === 'eyedropper') {
                     const pixelData = ctx.getImageData(Math.floor(pos.x), Math.floor(pos.y), 1, 1).data;
                     const hex = "#" + ("000000" + rgbToHex(pixelData[0], pixelData[1], pixelData[2])).slice(-6);
                     currentBrush.color = hex;
                     colorPicker.value = hex;
                     colorPickerContainer.style.backgroundColor = hex;
                     updateActiveBrushTip();
                     setTool('brush'); // Volta para o pincel automaticamente
                     // CORREÇÃO: Finaliza a função aqui para impedir que listeners de movimento sejam adicionados.
                     // Isso evita travamentos ao arrastar com a ferramenta ativa.
                     return; 
                }
            
                // Lógica do WARP
                if (currentTool === 'warp' && warpGrid) {
                    let found = null;

                    // Adiciona listeners de movimento e soltura
                    window.addEventListener('pointermove', handleDrawMove);
                    window.addEventListener('pointerup', handleDrawEnd);
                    window.addEventListener('mousemove', handleDrawMove); // Garante compatibilidade
                    window.addEventListener('mouseup', handleDrawEnd);    // Garante compatibilidade

                    for (let i = 0; i < warpGrid.length; i++) {
                        for (let j = 0; j < warpGrid[i].length; j++) {
                            const p = warpGrid[i][j]; // Raio de detecção aumentado para 12
                            if (Math.hypot(pos.x - p.x, pos.y - p.y) < 12) {
                                found = { r: i, c: j };
                            }
                        }
                    }
                    if (found) {
                        activeWarpNode = found;
                        // Adiciona listeners de movimento e soltura
                        window.addEventListener('pointermove', handleDrawMove);
                        window.addEventListener('pointerup', handleDrawEnd);
                        window.addEventListener('mousemove', handleDrawMove); // Garante compatibilidade
                        window.addEventListener('mouseup', handleDrawEnd);    // Garante compatibilidade
                        renderCanvas();
                    } else { // Se clicou fora de um nó, não faz nada, mantém a ferramenta ativa
                    }
                    return;
                }

                if (currentTool === 'puppet') {
                    handlePuppetStart(pos);
                    return;
                }

                // 2. Lógica de Seleção (Transformação) - CORRIGIDA
                if (currentTool === 'selection' && selectionCanvas) {
                    activeHandle = getHandleAt(pos);
                    
                    if (activeHandle) {
                        dragStart = pos;
                        initialTransform = JSON.parse(JSON.stringify(selectionTransform));
                        
                        // ADICIONA TODOS OS LISTENERS ANTES DE RETORNAR
                        window.addEventListener('pointermove', handleDrawMove);
                        window.addEventListener('pointerup', handleDrawEnd);
                        window.addEventListener('mousemove', handleDrawMove);
                        window.addEventListener('mouseup', handleDrawEnd);
                        return; // Sai da função aqui para não iniciar desenho ou nova seleção
                    } else {
                        // Clicou fora da seleção, mas a ferramenta de seleção está ativa.
                        // Aplica a transformação e volta para o pincel.
                        applyAndSaveTransformation();
                        setTool('brush'); 
                        
                        // *** CORREÇÃO CRÍTICA ***
                        // Adicionamos 'return' aqui. Sem isso, o código descia e
                        // iniciava o desenho (brush) imediatamente no mesmo clique.
                        return; 
                    }
                } 
                
                if (currentTool === 'bucket') {
                     // CORREÇÃO: Ação de clique único. Executa e finaliza a interação.
                     // O 'return' impede que listeners de 'arrastar' sejam adicionados, prevenindo o travamento.
                     floodFill(Math.floor(pos.x), Math.floor(pos.y));
                     return; 
                } 
                
                if (currentTool === 'brush' || currentTool === 'eraser') {
                    // --- CORREÇÃO DEFINITIVA DO "DESENHO FANTASMA" ---
                    // Se houver uma seleção ativa de uma ferramenta anterior (seleção, marionete, etc.),
                    // esta lógica garante que o clique atual APENAS aplique a transformação pendente.
                    // O 'return' impede que a lógica de desenho (isDrawing = true) seja executada
                    // na mesma interação, prevenindo a condição de corrida que causava o bug.
                    if (selectionCanvas) {
                        applyAndSaveTransformation(); // Aplica a transformação pendente.
                        setTool('brush'); // Garante que a ferramenta volte para o pincel.
                        return; // IMPORTANTE: Impede a execução do código de desenho nesta mesma interação.
                    }

                    if (timelineFramesData.length === 0) return;
                    isDrawing = true;
                    smoothPointer = { x: pos.x, y: pos.y };
                    [lastX, lastY] = [pos.x, pos.y];

                    // --- LÓGICA DE DESENHO MODIFICADA ---
                    // 1. Cria um snapshot do estado atual da camada
                    tempDrawCanvas = document.createElement('canvas');
                    tempDrawCanvas.width = CANVAS_WIDTH;
                    tempDrawCanvas.height = CANVAS_HEIGHT;
                    const currentLayer = timelineFramesData[currentFrameIndex].layers[currentLayerIndex];
                    const currentImageData = currentLayer.history[currentLayer.historyIndex];
                    tempDrawCanvas.getContext('2d').putImageData(currentImageData, 0, 0);

                    // 2. Cria um cache do fundo (todas as camadas abaixo)
                    renderCanvas(currentLayerIndex); 
                    const bgCtx = drawingBackgroundCanvas.getContext('2d');
                    bgCtx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                    bgCtx.drawImage(mainCanvas, 0, 0);

                    // 3. Limpa o canvas do traço para começar um novo
                    strokeCtx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                    // 4. Desenha o primeiro "ponto" do traço no canvas de traço
                    draw(e, strokeCtx);

                    // 5. Renderiza o resultado combinado na tela
                    renderLiveStroke();

                } else if (currentTool === 'selection') {
                     isSelecting = true;
                     selectionPath = [pos];
                }
            
                // Adiciona os novos listeners DEPOIS que toda a lógica de início foi processada.
                window.addEventListener('pointermove', handleDrawMove);
                window.addEventListener('pointerup', handleDrawEnd);
                window.addEventListener('mousemove', handleDrawMove);
                window.addEventListener('mouseup', handleDrawEnd);
            };

            // NOVA FUNÇÃO DE LIMPEZA CENTRALIZADA
            function cleanupGlobalPointerListeners() {
                window.removeEventListener('pointermove', handleDrawMove);
                window.removeEventListener('pointerup', handleDrawEnd);
                window.removeEventListener('mousemove', handleDrawMove);
                window.removeEventListener('mouseup', handleDrawEnd);
                window.removeEventListener('pointermove', handlePuppetMove);
                window.removeEventListener('pointerup', handlePuppetUp);
            }

            // Lógica de arrastar o canvas
            canvasWrapper.addEventListener('pointerdown', (e) => {
                // Ferramenta Mão (botão 0), Botão do meio (1) ou Espaço pressionado (botão 0)
                if ((currentTool === 'pan' && e.button === 0) || e.button === 1 || (e.button === 0 && (e.getModifierState('Space') || keys['Space']))) {
                    isPanning = true;
                    startPanX = e.clientX - panX; 
                    startPanY = e.clientY - panY;
                    canvasWrapper.style.cursor = 'grabbing';
                    e.preventDefault(); // Impede desenhar enquanto arrasta
                }
            });

            const handleDrawMove = (e) => {
                // CORREÇÃO: A condição foi simplificada. A verificação de 'activeHandle' já cobre o caso da seleção.
                // A verificação de 'activeWarpNode' cobre os casos de 'warp' e 'puppet'.
                if (!isDrawing && !isSelecting && !isDrawingPuppetLasso && !activeHandle && !activeWarpNode && !(activeWarpNode && activeWarpNode.type === 'puppet')) return;
                if (e.pointerId !== undefined && activePointerId !== null && activePointerId !== e.pointerId && e.pressure === undefined) {
                    return;
                }

                // Esta função agora funciona perfeitamente, mesmo fora do canvas
                const pos = getMousePos(mainCanvas, e);
            
                // Desenho do Lasso do Puppet
                if (isDrawingPuppetLasso) {
                    const last = puppetPins[puppetPins.length - 1];
                    // Adiciona ponto se moveu o suficiente
                    if (!last || Math.hypot(pos.x - last.x, pos.y - last.y) > 5) {
                        puppetPins.push(pos);
                        renderCanvas();
                    }
                    return;
                }

                // Movimento do PUPPET/WARP
                // Nota: O movimento do Puppet agora é tratado em handlePuppetMove, mas mantemos isso
                // caso activeWarpNode venha da ferramenta Warp Grid antiga (se 'r' e 'c' existirem).
                if (activeWarpNode && activeWarpNode.r !== undefined) {
                     if (currentTool === 'warp' && warpGrid) {
                        warpGrid[activeWarpNode.r][activeWarpNode.c].x = pos.x;
                        warpGrid[activeWarpNode.r][activeWarpNode.c].y = pos.y;
                        renderCanvas();
                     }
                     return;
                }
                
                // Se for Puppet Move, já é tratado pelo listener específico handlePuppetMove
                if (activeWarpNode && activeWarpNode.type === 'puppet') {
                    return;
                }
            
                // Movimento da SELEÇÃO (Mover / Redimensionar / Rotacionar)
                // CORREÇÃO: Adicionada verificação para garantir que esta lógica só rode para a ferramenta de seleção.
                if (activeHandle && currentTool === 'selection') {
                    const { x, y, width, height, rotation } = initialTransform;
                    const cx = x + width / 2;
                    const cy = y + height / 2;
            
                    const dx = pos.x - dragStart.x;
                    const dy = pos.y - dragStart.y;

                    if (activeHandle === 'move') {
                        selectionTransform.x = x + dx;
                        selectionTransform.y = y + dy;
                    } else if (activeHandle === 'rot') {
                        const startAngle = Math.atan2(dragStart.y - cy, dragStart.x - cx);
                        const currentAngle = Math.atan2(pos.y - cy, pos.x - cx);
                        selectionTransform.rotation = initialTransform.rotation + (currentAngle - startAngle);
                    } else {
                        // A lógica de redimensionamento (handles de canto/lado) vai aqui.
                        // Esta parte estava faltando e foi adicionada para corrigir o bug.
                        const originalMouseVector = {
                            x: dragStart.x - cx,
                            y: dragStart.y - cy
                        };
                        const currentMouseVector = {
                            x: pos.x - cx,
                            y: pos.y - cy
                        };

                        // Rotaciona os vetores do mouse para o sistema de coordenadas local da seleção
                        const localInitialMouse = {
                            x: originalMouseVector.x * Math.cos(-rotation) - originalMouseVector.y * Math.sin(-rotation),
                            y: originalMouseVector.x * Math.sin(-rotation) + originalMouseVector.y * Math.cos(-rotation)
                        };
                        const localCurrentMouse = {
                            x: currentMouseVector.x * Math.cos(-rotation) - currentMouseVector.y * Math.sin(-rotation),
                            y: currentMouseVector.x * Math.sin(-rotation) + currentMouseVector.y * Math.cos(-rotation)
                        };

                        const scaleX = localCurrentMouse.x / localInitialMouse.x;
                        const scaleY = localCurrentMouse.y / localInitialMouse.y;

                        let newWidth = width;
                        let newHeight = height;

                        if (activeHandle.includes('r')) newWidth = width * scaleX;
                        if (activeHandle.includes('l')) newWidth = width * scaleX;
                        if (activeHandle.includes('b')) newHeight = height * scaleY;
                        if (activeHandle.includes('t')) newHeight = height * scaleY;

                        // Calcula o novo centro após o redimensionamento para manter a posição correta
                        const newCX = cx + (newWidth - width) / 2 * Math.cos(rotation);
                        const newCY = cy + (newWidth - width) / 2 * Math.sin(rotation);

                        selectionTransform.width = Math.abs(newWidth);
                        selectionTransform.height = Math.abs(newHeight);
                        // Ajusta a posição para que o redimensionamento pareça vir do centro
                        selectionTransform.x = newCX - selectionTransform.width / 2;
                        selectionTransform.y = newCY - selectionTransform.height / 2;

                    }
                    renderCanvas();

                } else if (isSelecting) {
                    selectionPath.push(pos);
                    renderCanvas(); 

                } else if (isDrawing) {
                    draw(e, strokeCtx); // Continua desenhando a forma do traço
                    renderLiveStroke(); // Renderiza a composição ao vivo
                }
            };

            const handleDrawEnd = (e) => {
                // --- CORREÇÃO CRÍTICA DE ESTABILIDADE (CANETA/TOQUE) ---
                // Garante que o evento de "soltar" corresponda EXATAMENTE ao ponteiro que iniciou a ação.
                // Isso impede que um evento de "levantar a caneta" finalize uma ação que foi iniciada
                // pelo mouse, ou vice-versa, o que causava os travamentos.
                if (e.pointerId !== activePointerId) return;

                activeWarpNode = null;
                activeHandle = null;
                activePointerId = null;
                
                if (e.type === 'pointerup') {
                    try { mainCanvas.releasePointerCapture(e.pointerId); } catch(err) {}
                }
                
                // A lógica de finalização foi movida para dentro dos handlers específicos (handlePuppetUp, etc)
                cleanupGlobalPointerListeners();
                // ou para o final do handleDrawStart para ferramentas de um clique.
                if (isDrawingPuppetLasso) {
                    isDrawingPuppetLasso = false;
                    if (puppetPins.length > 2) {
                        // Fecha o laço e cria o puppet
                        selectionPath = [...puppetPins, puppetPins[0]];
                        finalizeAndCaptureSelection();
                        createWarpGridFromSelection();
                        
                        if (selectionCanvas && warpGrid) {
                             puppets.push({
                                canvas: selectionCanvas,
                                transform: { ...selectionTransform },
                                grid: warpGrid,
                                pins: [] // Sem pinos iniciais no modo freehand
                            });
                            selectionCanvas = null;
                            warpGrid = null;
                            puppetPins = [];
                            selectionPath = [];
                        }
                    } else {
                        puppetPins = []; // Cancela se for muito curto
                    }
                    renderCanvas();
                } 
                else if (isDrawing) { stopDrawing(); } 
                else if (isSelecting) {
                    isSelecting = false;
                    finalizeAndCaptureSelection();
                }
            };

            const stopDrawing = () => {
                if (isDrawing) {
                    // Une o traço finalizado com o snapshot da camada
                    const tempCtx = tempDrawCanvas.getContext('2d');
                    tempCtx.globalAlpha = currentBrush.opacity;
                    if (currentTool === 'eraser') {
                        tempCtx.globalCompositeOperation = 'destination-out';
                    } else {
                        tempCtx.globalCompositeOperation = 'source-over';
                    }
                    tempCtx.drawImage(strokeCanvas, 0, 0);

                    // Salva o resultado no histórico
                    // Optimization: In the future, save 'tempDrawCanvas' as Blob to IndexedDB here
                    const finalData = tempCtx.getImageData(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                    saveHistoryState(finalData);
                    
                    // Async Disk Save (Fire and Forget)
                    // FrameManager.saveFrameToDisk(`f${currentFrameIndex}_l${currentLayerIndex}_${Date.now()}`, await new Response(finalData.data).blob());

                    isDrawing = false;
                    tempDrawCanvas = null;
                    
                    updateLayerPanelAndHistoryIndicators();
                    renderCanvas();

                    if (currentLayerIndex === 0) { // Background layer
                        timelineFramesData.forEach(frame => frame.isDirty = true);
                        updateUI();
                    } else {
                        timelineFramesData[currentFrameIndex].isDirty = true;
                        if ('requestIdleCallback' in window) {
                            requestIdleCallback(updateCurrentFrameThumbnail);
                        } else {
                            setTimeout(updateCurrentFrameThumbnail, 50);
                        }
                    }
                }
            };

            // Adiciona os listeners de "início" ao canvas
            mainCanvas.addEventListener('pointerdown', handleDrawStart);
            mainCanvas.addEventListener('mousedown', handleDrawStart);
            
            // Previne o menu de contexto no canvas (clique direito)
            mainCanvas.addEventListener('contextmenu', (e) => e.preventDefault());
            // Previne seleção de texto fantasma no iOS/Safari
            mainCanvas.addEventListener('touchstart', (e)=>{ e.preventDefault(); }, { passive:false });

            // --- Listeners de Zoom e Pan ---

            // Zoom com a roda do mouse
            canvasWrapper.addEventListener('wheel', (e) => {
                if (e.ctrlKey || e.metaKey) { // Zoom apenas com Ctrl pressionado (padrão de design)
                     e.preventDefault();
                     const zoomSensitivity = 0.001;
                     const delta = -e.deltaY * zoomSensitivity;
                     const newScale = Math.min(Math.max(0.1, scale + delta), 5);
 
                     // --- ALTERAÇÃO: Lógica de zoom centralizado ---
                     const rect = canvasWrapper.parentElement.getBoundingClientRect();
                     const centerX = rect.width / 2;
                     const centerY = rect.height / 2;
 
                     panX = centerX - (centerX - panX) * (newScale / scale);
                     panY = centerY - (centerY - panY) * (newScale / scale);
                     scale = newScale;
 
                     applyTransform();
                }
            }, { passive: false });

            // Pan (Arrastar com Espaço + Clique ou Botão do Meio)
            window.addEventListener('pointermove', (e) => {
                if (isPanning) {
                    panX = e.clientX - startPanX;
                    panY = e.clientY - startPanY;
                    applyTransform();
                }
            });

            window.addEventListener('pointerup', () => {
                if (isPanning) {
                    isPanning = false;
                    canvasWrapper.style.cursor = (keys['Space']) ? 'grab' : 'crosshair';
                }
            });

            zoomSlider.addEventListener('input', (e) => {
                const newScale = parseFloat(e.target.value);
                
                // --- ALTERAÇÃO: Lógica de zoom centralizado (unificada) ---
                const rect = canvasWrapper.parentElement.getBoundingClientRect();
                const centerX = rect.width / 2;
                const centerY = rect.height / 2;
                
                panX = centerX - (centerX - panX) * (newScale / scale);
                panY = centerY - (centerY - panY) * (newScale / scale);
                scale = newScale;
                
                zoomValue.textContent = `${newScale.toFixed(1)}x`;
                applyTransform();
            });

            // Helper function to convert RGB to Hex
            function rgbToHex(r, g, b) {
                return ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
            }

            function setTool(tool) {
                // Se estivemos na ferramenta de seleção ou warp e mudamos para outra coisa, aplica a alteração (carimba)
                const isDeformTool = (t) => ['selection', 'puppet'].includes(t);
 
                // CORREÇÃO: Se estivermos saindo de uma ferramenta de deformação para uma que não é,
                // ou se estivermos mudando para a ferramenta de seleção (para criar uma *nova* seleção),
                // devemos aplicar a transformação pendente.
                if (selectionCanvas && isDeformTool(currentTool) && (!isDeformTool(tool) || tool === 'selection')) {
                     applyAndSaveTransformation();
                }
            
                // Limpa a grid se sair da ferramenta puppet
                if (tool !== 'puppet') {
                    warpGrid = null;
                    // puppetPins são mantidos até que uma nova seleção seja feita
                    // puppets = []; // NÃO limpamos puppets aqui para permitir trocar de ferramenta e voltar (opcional)
                    activeWarpNode = null;
                    canvasWrapper.style.cursor = 'crosshair';
                }
                
                // Gerencia classes dos botões
                selectionToolBtn.classList.remove('active');
                paintBucketBtn.classList.remove('active');
                eyedropperBtn.classList.remove('active');
                panToolBtn.classList.remove('active');
                puppetToolBtn.classList.remove('active'); 
                toolSwitch.checked = false;
                head3dBtn.classList.remove('active');

                // Se não for a ferramenta 3D, esconde o wrapper
                if (tool !== 'head3d') {
                    // CORREÇÃO: Se estiver saindo da ferramenta 3D com uma animação ativa, aplica a pose atual
                    if (currentTool === 'head3d' && typeof headMesh !== 'undefined' && headMesh) {
                        applyHead3D();
                    }

                    head3dWrapper.style.display = 'none';
                    // Se estava rodando, limpa
                    cleanupHead3D();
                }
                
                currentTool = tool;
            
                switch (currentTool) {
                    case 'selection':
                        selectionToolBtn.classList.add('active');
                        canvasWrapper.style.cursor = 'move';
                        break;
                        
                    case 'pan':
                        panToolBtn.classList.add('active');
                        canvasWrapper.style.cursor = 'grab';
                        break;
                        
                    case 'bucket':
                        paintBucketBtn.classList.add('active');
                        break;
                        
                    case 'eyedropper':
                        eyedropperBtn.classList.add('active');
                        break;
                        
                    case 'eraser':
                        toolSwitch.checked = true;
                        break;
                        
                    case 'brush':
                    default:
                        // cursor padrão
                        break;
                    
                    case 'puppet':
                        puppetToolBtn.classList.add('active');
                        // Se já houver uma seleção, mostra a grade e os controles
                        if (selectionCanvas && !warpGrid) {
                                createWarpGridFromSelection();
                        }
                        // Se tiver puppets na lista, eles serão renderizados
                        else {
                            // Se não houver seleção, ainda mostra o slider para pré-configuração
                        }
                        canvasWrapper.style.cursor = 'crosshair';
                        break;
                    
                    case 'head3d':
                        head3dBtn.classList.add('active');
                        break;
                }
                renderCanvas(); // Força um redesenho para mostrar a grade
            }
            
            eyedropperBtn.addEventListener('click', () => {
                if (currentTool === 'eyedropper') {
                    setTool('brush');
                } else {
                    setTool('eyedropper');
                }
            });

            panToolBtn.addEventListener('click', () => {
                if (currentTool === 'pan') {
                    setTool('brush');
                } else {
                    setTool('pan');
                }
            });

            selectionToolBtn.addEventListener('click', () => {
                // NOVO: Lógica de Ligar/Desligar
                if (currentTool === 'selection') {
                    applyAndSaveTransformation(); // Aplica a seleção antes de desligar
                    setTool('brush'); // Volta para o pincel
                } else {
                    setTool('selection');
                }
            });

            paintBucketBtn.addEventListener('click', () => {
                if (currentTool === 'bucket') {
                    setTool('brush');
             } else {
                    setTool('bucket');
                }
            });

            // Junto com os outros listeners de botões
            puppetToolBtn.addEventListener('click', () => {
                if (currentTool === 'puppet') {
                    applyAndSaveTransformation(); // Aplica a deformação antes de desligar
                    setTool('brush');
                } else {
                    setTool('puppet');
                }
            });

            // --- LÓGICA CARTOON ANIMATOR 360 INTEGRADA ---

            function toggleHead3D() {
                if (currentTool === 'head3d') {
                    setTool('brush');
                } else {
                    activateHead3D();
                }
            }

            head3dBtn.addEventListener('click', toggleHead3D);

            function activateHead3D() {
                setTool('head3d');
                head3dWrapper.style.display = 'block';
                
                // 1. Snapshot do canvas atual para usar como imagem base
                // Renderiza tudo (sem onion skin) para um canvas temporário
                const snapCanvas = document.createElement('canvas');
                snapCanvas.width = CANVAS_WIDTH;
                snapCanvas.height = CANVAS_HEIGHT;
                const snapCtx = snapCanvas.getContext('2d');
                
                // Captura APENAS a camada atual para garantir transparência (estilo Puppet)
                const currentLayer = timelineFramesData[currentFrameIndex].layers[currentLayerIndex];
                if (currentLayer && currentLayer.history[currentLayer.historyIndex]) {
                    snapCtx.putImageData(currentLayer.history[currentLayer.historyIndex], 0, 0);
                }

                headImg = new Image();
                headImg.onload = () => {
                    // Ajusta o canvas da ferramenta 3D para bater com o tamanho do projeto
                    head3dCanvas.width = CANVAS_WIDTH;
                    head3dCanvas.height = CANVAS_HEIGHT;
                    headForegroundCanvas.width = CANVAS_WIDTH;
                    headForegroundCanvas.height = CANVAS_HEIGHT;
                    headPoints = [];
                    isHeadClosed = false;
                    btnAnimateHead.style.display = 'none';
                    threeContainer.style.display = 'none';
                    btnApplyHead.style.display = 'none';
                    btnCancelHead.style.display = 'none';
                    threeContainer.innerHTML = ''; // Limpa cenas anteriores
                    
                    redrawHead3D();
                };
                headImg.src = snapCanvas.toDataURL();
            }

            function redrawHead3D(mousePos) {
                head3dCtx.clearRect(0, 0, head3dCanvas.width, head3dCanvas.height);
                if (headPoints.length === 0) return;

                // Estilo Marionete (Puppet): Magenta, Dashed, Sem Neon, Sem Preenchimento
                head3dCtx.save();
                head3dCtx.strokeStyle = 'rgba(255, 0, 255, 1.0)';
                head3dCtx.fillStyle = 'rgba(255, 0, 255, 1.0)';
                head3dCtx.lineWidth = 2;
                head3dCtx.setLineDash([5, 5]);

                head3dCtx.beginPath();
                
                head3dCtx.moveTo(headPoints[0].x, headPoints[0].y);
                headPoints.forEach(p => head3dCtx.lineTo(p.x, p.y));
                
                if (isHeadClosed) {
                    head3dCtx.closePath();
                    // Sem preenchimento para garantir visibilidade
                }
                head3dCtx.stroke();

                // Pontos de ancoragem removidos para o modo laço livre
                
                head3dCtx.restore();
            }

            head3dCanvas.addEventListener('pointerdown', (e) => {
                if (currentTool !== 'head3d' || isHeadClosed) return;
                e.preventDefault();
                const pos = getMousePos(head3dCanvas, e);
                
                isDrawingHead = true;
                headPoints = [pos];
                head3dCanvas.setPointerCapture(e.pointerId);
                redrawHead3D();
            });

            head3dCanvas.addEventListener('pointermove', (e) => {
                if (!isDrawingHead) return;
                const pos = getMousePos(head3dCanvas, e);
                
                // Suavização básica: adiciona ponto se moveu mais que 2px
                const lastP = headPoints[headPoints.length - 1];
                if (Math.hypot(pos.x - lastP.x, pos.y - lastP.y) > 2) {
                    headPoints.push(pos);
                    redrawHead3D();
                }
            });

            head3dCanvas.addEventListener('pointerup', (e) => {
                if (!isDrawingHead) return;
                isDrawingHead = false;
                head3dCanvas.releasePointerCapture(e.pointerId);

                if (headPoints.length > 10) {
                    isHeadClosed = true;
                    redrawHead3D();
                    startHead3DAnimation();
                } else {
                    headPoints = [];
                    redrawHead3D();
                }
            });

            function startHead3DAnimation() {
                if(headPoints.length < 3) return;

                const minX = Math.min(...headPoints.map(p => p.x));
                const maxX = Math.max(...headPoints.map(p => p.x));
                const minY = Math.min(...headPoints.map(p => p.y));
                const maxY = Math.max(...headPoints.map(p => p.y));
                const width = maxX - minX;
                const height = maxY - minY;

                // Cria a textura recortada
                const texCanvas = document.createElement('canvas');
                texCanvas.width = width; texCanvas.height = height;
                const tctx = texCanvas.getContext('2d');
                tctx.translate(-minX, -minY);
                tctx.beginPath();
                tctx.moveTo(headPoints[0].x, headPoints[0].y);
                headPoints.forEach(p => tctx.lineTo(p.x, p.y));
                tctx.closePath(); tctx.clip();
                tctx.drawImage(headImg, 0, 0);

                // Limpa o canvas de UI e inicia o 3D
                head3dCtx.clearRect(0, 0, head3dCanvas.width, head3dCanvas.height);
                
                // Inicia a cena e passa um callback para recortar o buraco APENAS quando a textura carregar
                initHead3DScene(texCanvas.toDataURL(), minX, minY, width, height, () => {
                    if (headPoints.length === 0) return;
                    
                    // --- CORREÇÃO: "Levanta" a camada atual, redesenhando as outras por baixo ---
                    // Isso mantém o fundo visível e remove apenas o pedaço da camada que virou 3D
                    ctx.save();
                    ctx.beginPath();
                    ctx.moveTo(headPoints[0].x, headPoints[0].y);
                    headPoints.forEach(p => ctx.lineTo(p.x, p.y));
                    ctx.closePath();
                    ctx.clip();

                    // 1. Limpa a área (buraco) na tela
                    ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                    // 2. Redesenha as camadas: Abaixo no buraco, Acima no foreground
                    const frameData = timelineFramesData[currentFrameIndex];
                    const fgCtx = headForegroundCanvas.getContext('2d');
                    fgCtx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                    for (let i = 0; i < frameData.layers.length; i++) {
                        if (i === currentLayerIndex) continue; // Pula a camada ativa (que virou 3D)
                        const layer = frameData.layers[i];
                        if (layer.visible) {
                            sharedTempLayerCtx.putImageData(layer.history[layer.historyIndex], 0, 0);
                            
                            if (i < currentLayerIndex) {
                                // Camadas abaixo: Desenha no buraco (fundo)
                                ctx.globalAlpha = layer.opacity;
                                ctx.globalCompositeOperation = layer.blendMode || 'source-over';
                                ctx.drawImage(sharedTempLayerCanvas, 0, 0);
                            } else {
                                // Camadas acima: Desenha no foreground (frente do 3D)
                                fgCtx.globalAlpha = layer.opacity;
                                fgCtx.globalCompositeOperation = layer.blendMode || 'source-over';
                                fgCtx.drawImage(sharedTempLayerCanvas, 0, 0);
                            }
                        }
                    }

                    ctx.restore();
                    ctx.globalAlpha = 1.0;
                    ctx.globalCompositeOperation = 'source-over';
                });
            }

            function initHead3DScene(textureUrl, x, y, w, h, onTextureLoaded) {
                threeContainer.style.display = 'block';
                rotX = 0; rotY = 0;
                headScene = new THREE.Scene();
                headCamera = new THREE.OrthographicCamera(0, CANVAS_WIDTH, 0, CANVAS_HEIGHT, 0.1, 5000);
                headCamera.position.z = 2000;
                headRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, preserveDrawingBuffer: true });
                // CORREÇÃO: false impede que o ThreeJS defina style.width/height em pixels,
                // permitindo que o CSS width: 100% controle o tamanho visual corretamente.
                headRenderer.setSize(CANVAS_WIDTH, CANVAS_HEIGHT, false); 
                headRenderer.domElement.style.width = '100%';
                headRenderer.domElement.style.height = '100%';
                
                threeContainer.innerHTML = '';
                threeContainer.appendChild(headRenderer.domElement);

                const texture = new THREE.TextureLoader().load(textureUrl, () => {
                    if (onTextureLoaded) onTextureLoaded();
                });
                texture.flipY = false;
                const geometry = new THREE.PlaneGeometry(w, h, 32, 32);
                const positions = geometry.attributes.position;
                for (let i = 0; i < positions.count; i++) {
                    const px = positions.getX(i); const py = positions.getY(i);
                    const dist = Math.sqrt((px*px)/(w*w) + (py*py)/(h*h));
                    positions.setZ(i, Math.cos(dist * Math.PI) * (w / 4));
                }
                geometry.computeVertexNormals();
                const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide });
                headMesh = new THREE.Mesh(geometry, material);
                headMesh.rotation.set(0, 0, 0);
                
                // Posicionamento: Como a câmera é (0, W, 0, H), Y=0 é topo e Y=H é base.
                // O mesh é centralizado, então posicionamos no centro da seleção.
                headMesh.position.set(x + w/2, y + h/2, 0);

                headScene.add(headMesh);

                let isDragging3D = false;
                let lastX = 0;
                let lastY = 0;

                threeContainer.onpointerdown = (e) => {
                    isDragging3D = true;
                    lastX = e.clientX;
                    lastY = e.clientY;
                    threeContainer.setPointerCapture(e.pointerId);
                    threeContainer.style.cursor = 'grabbing';
                    e.preventDefault();
                };

                threeContainer.onpointermove = (e) => {
                    if (!isDragging3D) return;
                    const deltaX = e.clientX - lastX;
                    const deltaY = e.clientY - lastY;
                    lastX = e.clientX;
                    lastY = e.clientY;

                    rotY += deltaX * 0.01; 
                    rotX -= deltaY * 0.01;
                    
                    if (headMesh) {
                        headMesh.rotation.y = rotY; 
                        headMesh.rotation.x = rotX;
                    }
                };

                threeContainer.onpointerup = (e) => {
                    isDragging3D = false;
                    threeContainer.releasePointerCapture(e.pointerId);
                    threeContainer.style.cursor = 'grab';
                };

                function animateHead() {
                    if (currentTool !== 'head3d') return;
                    headAnimationId = requestAnimationFrame(animateHead);
                    headRenderer.render(headScene, headCamera);
                }
                animateHead();
            }

            function applyHead3D() {
                if (!headMesh || !headRenderer) return;

                // Renderiza o estado atual do 3D para garantir que temos a última pose
                headRenderer.render(headScene, headCamera);
                
                const currentLayers = timelineFramesData[currentFrameIndex].layers;
                const frame = currentLayers[currentLayerIndex];
                const targetImageData = frame.history[frame.historyIndex];

                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = CANVAS_WIDTH;
                tempCanvas.height = CANVAS_HEIGHT;
                const tCtx = tempCanvas.getContext('2d');

                // 1. Desenha a camada original
                tCtx.putImageData(targetImageData, 0, 0);

                // 2. Apaga a área onde a cabeça estava (recorte)
                tCtx.save();
                tCtx.globalCompositeOperation = 'destination-out';
                tCtx.beginPath();
                if (headPoints.length > 0) {
                    tCtx.moveTo(headPoints[0].x, headPoints[0].y);
                    headPoints.forEach(p => tCtx.lineTo(p.x, p.y));
                }
                tCtx.closePath();
                tCtx.fill();

                tCtx.restore();

                // 3. Desenha a cabeça 3D na nova posição por cima
                // O canvas do ThreeJS já está no tamanho correto e transparente
                tCtx.drawImage(headRenderer.domElement, 0, 0);

                // 4. Salva no histórico
                saveHistoryState(tCtx.getImageData(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT));
                
                timelineFramesData[currentFrameIndex].isDirty = true;
                renderCanvas();
                updateCurrentFrameThumbnail();
            }

            function cleanupHead3D() {
                if (headAnimationId) cancelAnimationFrame(headAnimationId);
                threeContainer.onpointerdown = null;
                threeContainer.onpointermove = null;
                threeContainer.onpointerup = null;
                threeContainer.innerHTML = '';
                threeContainer.style.display = 'none';
                headPoints = [];
                isHeadClosed = false;
                isDrawingHead = false;
                btnAnimateHead.style.display = 'none';
                btnApplyHead.style.display = 'none';
                btnCancelHead.style.display = 'none';
                headMesh = null; // Limpa a referência do mesh
                head3dCtx.clearRect(0, 0, head3dCanvas.width, head3dCanvas.height);
                headForegroundCanvas.getContext('2d').clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            }

            btnApplyHead.addEventListener('click', () => {
                applyHead3D();
                setTool('brush'); // Sai da ferramenta (o que chama cleanup)
            });

            btnCancelHead.addEventListener('click', () => {
                headMesh = null; // Impede o auto-apply
                setTool('brush');
            });


            // --- INÍCIO DA LÓGICA CORRIGIDA PARA PINCEL E BORRACHA ---
            let lastBrushSize = parseInt(brushSizeSlider.value);
            const MAX_BRUSH_SIZE = parseInt(brushSizeSlider.max);

            toolSwitch.addEventListener('change', (e) => {
                if (e.target.checked) {
                    // Mudar para Borracha
                    setTool('eraser');
                    lastBrushSize = parseInt(brushSizeSlider.value);
                    // MODIFICAÇÃO: Define um tamanho fixo padrão para a borracha,
                    // independente do tamanho do pincel anterior.
                    const newEraserSize = 50;
                    brushSizeSlider.value = newEraserSize;
                    currentBrush.size = newEraserSize;
                } else {
                    // Voltar para Pincel
                    setTool('brush');
                    const savedSize = brushesConfig[currentBrush.type].size;
                    brushSizeSlider.value = savedSize;
                    currentBrush.size = savedSize;
                }
            });

            brushSizeSlider.addEventListener('input', (e) => {
                const newSize = parseInt(e.target.value);
                currentBrush.size = newSize;

                // Salva a configuração de tamanho apenas se estivermos no modo pincel
                if (!toolSwitch.checked) { // Equivalente a if(currentTool === 'brush')
                    brushesConfig[currentBrush.type].size = newSize;
                    lastBrushSize = newSize; // Atualiza para a lógica da borracha
                }
            });
            // --- FIM DA LÓGICA CORRIGIDA ---

            // --- INÍCIO DA LÓGICA DE OPACIDADE NÃO LINEAR ---
            brushOpacitySlider.addEventListener('input', (e) => {
                const sliderValue = parseInt(e.target.value);
                let newOpacity;

                if (currentBrush.type === 'airbrush') {
                    // Mapeia o slider para uma opacidade entre 1% e 5% para evitar "dobra" brusca
                    const minOp = 0.01; 
                    const maxOp = 0.05; 
                    newOpacity = minOp + (sliderValue / 100) * (maxOp - minOp);
                } else {
                    // Lógica para o intervalo de 0 a 99 (mapeia para 1% a 5%)
                    if (sliderValue <= 99) {
                        // 1. Calcula a progressão dentro do intervalo 0-99 (um valor de 0.0 a 1.0)
                        const progress = sliderValue / 99; 
                        
                        // 2. Define o intervalo de opacidade desejado (5% - 0.2% = 4.8%)
                        const MIN_OPACITY = 0.002;
                        const MAX_OPACITY_RANGE = 0.05;
                        const opacityRange = MAX_OPACITY_RANGE - MIN_OPACITY;
                        
                        // 3. Calcula a opacidade final começando em 0.2% e adicionando a progressão
                        newOpacity = MIN_OPACITY + (progress * opacityRange);
                    } 
                    // Lógica para quando o valor for exatamente 100
                    else {
                        newOpacity = 1; // 100% de opacidade
                    }
                }

                currentBrush.opacity = newOpacity;

                // Salva o valor original do slider (0-100) para poder restaurá-lo ao trocar de pincel
                if (currentTool === 'brush') {
                    brushesConfig[currentBrush.type].opacityValue = sliderValue;
                }
            });
            // --- FIM DA LÓGICA DE OPACIDADE NÃO LINEAR ---

            colorPickerContainer.addEventListener('click', () => {
                colorPicker.click();
            });

            colorPicker.addEventListener('input', (e) => {
                const newColor = e.target.value;
                const currentFrame = timelineFramesData[currentFrameIndex];
                const currentLayer = currentFrame.layers[currentLayerIndex];

                if (currentLayer && currentLayer.isBackground) {
                    // Lógica para mudar a cor do BACKGROUND
                    currentLayer.backgroundColor = newColor;
                    
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = CANVAS_WIDTH; tempCanvas.height = CANVAS_HEIGHT;
                    const ctx = tempCanvas.getContext('2d');
                    ctx.fillStyle = newColor;
                    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                    const newData = ctx.getImageData(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                    
                    currentLayer.history = [newData]; 
                    currentLayer.historyIndex = 0;
                    
                    timelineFramesData.forEach(f => f.isDirty = true);
                    renderCanvas();
                } else {
                    // Lógica padrão para mudar a cor do PINCEL
                    currentBrush.color = newColor;
                    updateActiveBrushTip(); // Atualiza a cor da ponta do pincel
                }
                colorPickerContainer.style.backgroundColor = newColor;
            });
            
            fillToleranceSlider.addEventListener('input', (e) => {
                fillTolerance = parseInt(e.target.value);
            });
            
            // History controls
            const undo = () => {
                const currentLayers = timelineFramesData[currentFrameIndex].layers;
                if (!currentLayers[currentLayerIndex]) return;
                const currentLayer = currentLayers[currentLayerIndex];
                if (currentLayer.historyIndex > 0) {
                    currentLayer.historyIndex--;
                    renderCanvas();
                    updateLayerPanelAndHistoryIndicators(); // Atualiza a aba de camadas/histórico

                    if (currentLayerIndex === 0) { // Background layer
                        timelineFramesData.forEach(frame => frame.isDirty = true);
                        updateUI();
                    } else {
                        timelineFramesData[currentFrameIndex].isDirty = true;
                        if ('requestIdleCallback' in window) {
                            requestIdleCallback(updateCurrentFrameThumbnail);
                        } else {
                            setTimeout(updateCurrentFrameThumbnail, 50);
                        }
                    }
                }
            };
            const redo = () => {
                const currentLayers = timelineFramesData[currentFrameIndex].layers;
                if (!currentLayers[currentLayerIndex]) return;
                const currentLayer = currentLayers[currentLayerIndex];
                if (currentLayer.historyIndex < currentLayer.history.length - 1) {
                    currentLayer.historyIndex++;
                    renderCanvas();
                    updateLayerPanelAndHistoryIndicators(); // Atualiza a aba de camadas/histórico
                    if (currentLayerIndex === 0) { // Background layer
                        timelineFramesData.forEach(frame => frame.isDirty = true);
                        updateUI();
                    } else {
                        timelineFramesData[currentFrameIndex].isDirty = true;
                        if ('requestIdleCallback' in window) {
                            requestIdleCallback(updateCurrentFrameThumbnail);
                        } else {
                            setTimeout(updateCurrentFrameThumbnail, 50);
                        }
                    }
                }
            };
            undoBtn.addEventListener('click', undo);
            redoBtn.addEventListener('click', redo);

            // Animation controls
            playPauseBtn.addEventListener('click', togglePlayState);
            const goToPrevFrame = () => {
                // --- CORREÇÃO: Garante que a seleção seja aplicada antes de mudar de quadro ---
                if (selectionCanvas) {
                    applyAndSaveTransformation(); // Aplica e já limpa o estado
                }

                if (!isPlaying && timelineFramesData.length > 0) {
                    const oldFrameIndex = currentFrameIndex;
                    currentFrameIndex = (currentFrameIndex - 1 + timelineFramesData.length) % timelineFramesData.length;
                    frameHoldCounter = 0; // Reseta o contador de hold ao mudar manualmente
                    currentLayerIndex = Math.min(preferredLayerIndex, timelineFramesData[currentFrameIndex].layers.length - 1);
                    // --- CORREÇÃO PUPPET (FINAL) ---
                    // Carrega os pinos do novo quadro selecionado.
                    puppetPins = timelineFramesData[currentFrameIndex]?.puppetPins || [];
                    renderCanvas(); 
                    updateActiveFrameUI(currentFrameIndex, oldFrameIndex); // Otimizado
                    updateLayerPanelAndHistoryIndicators();
                }
            };
            const goToNextFrame = () => {
                // --- CORREÇÃO: Garante que a seleção seja aplicada antes de mudar de quadro ---
                if (selectionCanvas) {
                    applyAndSaveTransformation(); // Aplica e já limpa o estado
                }

                if (!isPlaying && timelineFramesData.length > 0) {
                    const oldFrameIndex = currentFrameIndex;
                    currentFrameIndex = (currentFrameIndex + 1) % timelineFramesData.length;
                    frameHoldCounter = 0; // Reseta o contador de hold ao mudar manualmente
                    currentLayerIndex = Math.min(preferredLayerIndex, timelineFramesData[currentFrameIndex].layers.length - 1);
                    // --- CORREÇÃO PUPPET (FINAL) ---
                    // Carrega os pinos do novo quadro selecionado.
                    puppetPins = timelineFramesData[currentFrameIndex]?.puppetPins || [];
                    renderCanvas(); 
                    updateActiveFrameUI(currentFrameIndex, oldFrameIndex); // Otimizado
                    updateLayerPanelAndHistoryIndicators();
                }
            };

            const flipSelectionHorizontal = () => {
                if (!selectionCanvas) return;

                const newCanvas = document.createElement('canvas');
                newCanvas.width = selectionCanvas.width;
                newCanvas.height = selectionCanvas.height;
                const tempCtx = newCanvas.getContext('2d');
                
                tempCtx.translate(newCanvas.width, 0);
                tempCtx.scale(-1, 1);
                tempCtx.drawImage(selectionCanvas, 0, 0);
                
                selectionCanvas = newCanvas;
                renderCanvas();
            };

            copySelectionBtn.addEventListener('click', () => {
                if (!selectionCanvas) return;

                const copy = document.createElement('canvas');
                copy.width = selectionCanvas.width;
                copy.height = selectionCanvas.height;
                copy.getContext('2d').drawImage(selectionCanvas, 0, 0);
                
                clipboardSelection = {
                    image: copy,
                    transform: { ...selectionTransform }
                };
            });

            copyAllBtn.addEventListener('click', () => {
                const currentFrame = timelineFramesData[currentFrameIndex];
                if (!currentFrame) return;

                const layersData = [];
                currentFrame.layers.forEach((layer, index) => {
                    if (layer.visible && !layer.isBackground) {
                        const imageData = layer.history[layer.historyIndex];
                        if (imageData) {
                            const newImageData = new ImageData(
                                new Uint8ClampedArray(imageData.data),
                                imageData.width,
                                imageData.height
                            );
                            layersData.push({
                                index: index,
                                data: newImageData
                            });
                        }
                    }
                });

                if (layersData.length > 0) {
                    clipboardSelection = {
                        type: 'multi-layer',
                        layers: layersData
                    };
                }
            });

            pasteSelectionBtn.addEventListener('click', () => {
                if (!clipboardSelection) return;

                if (clipboardSelection.type === 'multi-layer') {
                    const currentFrame = timelineFramesData[currentFrameIndex];
                    let pastedAny = false;

                    clipboardSelection.layers.forEach(layerInfo => {
                        const targetLayer = currentFrame.layers[layerInfo.index];
                        if (targetLayer && !targetLayer.isBackground) {
                            const pasteData = new ImageData(
                                new Uint8ClampedArray(layerInfo.data.data),
                                layerInfo.data.width,
                                layerInfo.data.height
                            );

                            if (targetLayer.historyIndex < targetLayer.history.length - 1) {
                                targetLayer.history.splice(targetLayer.historyIndex + 1);
                            }
                            targetLayer.history.push(pasteData);
                            if (targetLayer.history.length > MAX_HISTORY_STATES) {
                                targetLayer.history.shift();
                            }
                            targetLayer.historyIndex = targetLayer.history.length - 1;
                            pastedAny = true;
                        }
                    });

                    if (pastedAny) {
                        timelineFramesData[currentFrameIndex].isDirty = true;
                        renderCanvas();
                        updateLayerPanelAndHistoryIndicators();
                        updateCurrentFrameThumbnail();
                    }
                } else if (clipboardSelection.image) {
                    if (timelineFramesData[currentFrameIndex].layers[currentLayerIndex].isBackground) {
                        return;
                    }

                    if (selectionCanvas) {
                        applyAndSaveTransformation();
                    }
                    
                    setTool('selection');
                    
                    const sourceImage = clipboardSelection.image;

                    selectionCanvas = document.createElement('canvas');
                    selectionCanvas.width = sourceImage.width;
                    selectionCanvas.height = sourceImage.height;
                    selectionCanvas.getContext('2d').drawImage(sourceImage, 0, 0);
                    
                    if (clipboardSelection.transform) {
                        selectionTransform = { ...clipboardSelection.transform };
                    } else {
                        selectionTransform = {
                            x: (CANVAS_WIDTH - selectionCanvas.width) / 2,
                            y: (CANVAS_HEIGHT - selectionCanvas.height) / 2,
                            width: selectionCanvas.width,
                            height: selectionCanvas.height,
                            rotation: 0
                        };
                    };
                    renderCanvas();
                }
            });
            flipHorizontalBtn.addEventListener('click', flipSelectionHorizontal);

addFrameBtn.addEventListener('click', () => {
                // Aplica transformações pendentes antes de mudar
                if (selectionCanvas) {
                    applyAndSaveTransformation(); 
                }

                const newFrame = {
                    duration: 1,
                    cachedCanvas: null, 
                    isDirty: true,      
                    puppetPins: [], 
                    bones: [], 
                    layers: [
                        globalBackgroundLayer // Usa o background compartilhado
                    ]
                };
                
                // Adiciona as outras camadas (vazias) para manter a estrutura
                const layerCount = timelineFramesData[0].layers.length;
                for(let i=1; i<layerCount; i++) {
                    newFrame.layers.push(createLayer(timelineFramesData[0].layers[i].name));
                }
                
                timelineFramesData.splice(currentFrameIndex + 1, 0, newFrame);
                currentFrameIndex++;
                selectedFrameIndices.clear();
                selectedFrameIndices.add(currentFrameIndex);
                
                currentLayerIndex = 1;
                preferredLayerIndex = 1;

                renderCanvas(); 
                updateUI(); 
                updateTimelineWidths();
            });
            
           duplicateFrameBtn.addEventListener('click', () => {
                let preservedPuppetsData = null;
                let preservedSelectionData = null;
                let layerWithHoleData = null;

                // 1. Lógica especial para manter o Puppet ativo ao duplicar
                // Agora suporta múltiplos puppets OU um puppet único em criação
                if (currentTool === 'puppet' && (puppets.length > 0 || (selectionCanvas && puppetPins.length > 0))) {
                    // A. Bake para o Frame ATUAL (para salvar o estado visual correto no histórico)
                    const currentLayers = timelineFramesData[currentFrameIndex].layers;
                    const frame = currentLayers[currentLayerIndex];
                    const targetImageData = frame.history[frame.historyIndex];
                    
                    // Captura o estado "com buraco" ANTES de fazer o bake (para usar no próximo frame)
                    layerWithHoleData = new ImageData(
                        new Uint8ClampedArray(targetImageData.data),
                        targetImageData.width,
                        targetImageData.height
                    );

                    // Se tiver um puppet único em edição (legado/transição), move para o array
                    if (selectionCanvas && puppetPins.length > 0 && puppets.length === 0) {
                        puppets.push({
                            canvas: selectionCanvas,
                            transform: { ...selectionTransform },
                            grid: warpGrid,
                            pins: puppetPins.map(p => ({...p}))
                        });
                    }

                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = CANVAS_WIDTH;
                    tempCanvas.height = CANVAS_HEIGHT;
                    const ctx = tempCanvas.getContext('2d');
                    ctx.putImageData(targetImageData, 0, 0);

                    // Desenha todos os puppets no canvas temporário para salvar o frame atual
                    puppets.forEach(p => {
                        renderWarpedSelection(ctx, p.grid, p.canvas, false);
                    });

                    // Salva no histórico do frame atual
                    const bakedImageData = ctx.getImageData(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                    saveHistoryState(bakedImageData);

                    // B. Clona os puppets para o novo frame
                    preservedPuppetsData = puppets.map(p => {
                        const newC = document.createElement('canvas');
                        newC.width = p.canvas.width; newC.height = p.canvas.height;
                        newC.getContext('2d').drawImage(p.canvas, 0, 0);
                        
                        // Clona grid e pins profundamente
                        const newGrid = p.grid.map(row => row.map(pt => ({...pt})));
                        const newPins = p.pins.map(pin => ({...pin, ox: pin.x, oy: pin.y})); // Reseta origem

                        return {
                            canvas: newC,
                            transform: { ...p.transform },
                            grid: newGrid,
                            pins: newPins
                        };
                    });

                    resetTransformationState(); 
                } 
                else if (selectionCanvas) {
                    // --- LÓGICA PARA MANTER SELEÇÃO ATIVA AO DUPLICAR ---
                    const currentLayers = timelineFramesData[currentFrameIndex].layers;
                    const frame = currentLayers[currentLayerIndex];
                    const targetImageData = frame.history[frame.historyIndex];
                    
                    // 1. Salva o estado da camada com o buraco (antes de aplicar)
                    layerWithHoleData = new ImageData(
                        new Uint8ClampedArray(targetImageData.data),
                        targetImageData.width,
                        targetImageData.height
                    );

                    // 2. Salva o canvas da seleção
                    const selCopy = document.createElement('canvas');
                    selCopy.width = selectionCanvas.width;
                    selCopy.height = selectionCanvas.height;
                    selCopy.getContext('2d').drawImage(selectionCanvas, 0, 0);
                    
                    preservedSelectionData = {
                        canvas: selCopy,
                        transform: { ...selectionTransform }
                    };

                    applyAndSaveTransformation(); 
                }

                if (timelineFramesData.length > 0) {
                    const indicesToDuplicate = Array.from(selectedFrameIndices).sort((a, b) => a - b);
                    const newFrames = [];

                    indicesToDuplicate.forEach(idx => {
                        const srcFrame = timelineFramesData[idx];
                        const newFrame = {
                            duration: srcFrame.duration || 1,
                            cachedCanvas: null,
                            isDirty: true,
                            puppetPins: JSON.parse(JSON.stringify(srcFrame.puppetPins || [])),
                            bones: JSON.parse(JSON.stringify(srcFrame.bones || [])),
                            layers: srcFrame.layers.map(l => {
                                if (l.isBackground) {
                                    return globalBackgroundLayer; // Referencia o background global
                                }
                                return duplicateLayerOptimized(l); // Duplica as outras camadas
                            })
                        };
                        newFrames.push(newFrame);
                    });

                    const insertIndex = indicesToDuplicate[indicesToDuplicate.length - 1] + 1;
                    timelineFramesData.splice(insertIndex, 0, ...newFrames);
                    
                    selectedFrameIndices.clear();
                    for(let i=0; i<newFrames.length; i++) selectedFrameIndices.add(insertIndex + i);
                    currentFrameIndex = insertIndex;

                    currentLayerIndex = Math.min(preferredLayerIndex, timelineFramesData[currentFrameIndex].layers.length - 1);
                    
                    // 3. Restaura o estado do Puppet no novo frame
                    if (preservedPuppetsData) {
                        puppets = preservedPuppetsData;
                        
                        // Restaura a camada com o buraco limpo (sem sombras de apagamento)
                        if (layerWithHoleData) {
                            const layer = timelineFramesData[currentFrameIndex].layers[currentLayerIndex];
                            // Substitui o histórico do novo frame (que veio com o bake duplicado) pelo estado com buraco
                            layer.history[layer.historyIndex] = layerWithHoleData;
                        }

                        currentTool = 'puppet';
                        puppetToolBtn.classList.add('active');
                        canvasWrapper.style.cursor = 'crosshair';
                    } else if (preservedSelectionData) {
                        // --- RESTAURA A SELEÇÃO NO NOVO FRAME ---
                        setTool('selection');
                        
                        selectionCanvas = preservedSelectionData.canvas;
                        selectionTransform = preservedSelectionData.transform;

                        if (layerWithHoleData) {
                            const layer = timelineFramesData[currentFrameIndex].layers[currentLayerIndex];
                            layer.history[layer.historyIndex] = layerWithHoleData;
                        }
                    }

                    renderCanvas();
                    updateUI();
                    updateTimelineWidths();
                }
            });

            deleteFrameBtn.addEventListener('click', () => {
                // --- CORREÇÃO: Garante que a seleção seja aplicada antes de mudar de quadro ---
                if (selectionCanvas) {
                    applyAndSaveTransformation(); // Aplica e já limpa o estado
                }
                if (timelineFramesData.length > 1) {
                    const indicesToDelete = Array.from(selectedFrameIndices).sort((a, b) => b - a);
                    
                    // Evita deletar todos os quadros
                    if (indicesToDelete.length === timelineFramesData.length) {
                        indicesToDelete.pop(); // Mantém o primeiro (que é o último no sort desc)
                    }

                    indicesToDelete.forEach(idx => timelineFramesData.splice(idx, 1));

                    if (currentFrameIndex >= timelineFramesData.length) {
                        currentFrameIndex = timelineFramesData.length - 1;
                    }
                    selectedFrameIndices.clear();
                    selectedFrameIndices.add(currentFrameIndex);

                    currentLayerIndex = Math.min(preferredLayerIndex, timelineFramesData[currentFrameIndex].layers.length - 1);
                    renderCanvas(); 
                    updateUI();
                    updateTimelineWidths();
                }
            });
            
            // --- UPDATE: Arrastar e soltar para a timeline com Pointer Events (caneta/toque) ---
            let dragStartPos = { x: 0, y: 0 };
            let isDragging = false;
            let dragThreshold = 5; // O usuário precisa mover 5px para iniciar o arrasto
            let draggedFrameElement = null;
            let draggedFrameIndex = null;
            let placeholder = null;
            let dropIndicatorLine = null; 

            function createPlaceholder() { // MODIFICADO
                const p = document.createElement('div');
                p.className = 'flex-shrink-0 w-[54px] h-[30px] bg-zinc-800/50 rounded-lg border-2 border-dashed border-zinc-600 box-border transition-all duration-150 pointer-events-none';
                return p;
            }

            timelineFrames.addEventListener('pointerdown', (e) => {
                const frameElement = e.target.closest('.timeline-frame');
                if (!frameElement || e.button !== 0) return;

                draggedFrameElement = frameElement;
                draggedFrameIndex = parseInt(frameElement.dataset.frameIndex, 10);
                dragStartPos = { x: e.clientX, y: e.clientY };
                isDragging = false; 

                frameElement.setPointerCapture(e.pointerId);

                const onPointerMove = (moveEvent) => {
                    const dx = Math.abs(moveEvent.clientX - dragStartPos.x);
                    const dy = Math.abs(moveEvent.clientY - dragStartPos.y);

                    if (!isDragging && (dx > dragThreshold || dy > dragThreshold)) {
                        isDragging = true; 

                        document.body.style.cursor = 'grabbing';
                        
                        dropIndicatorLine = document.createElement('div');
                        const timelineRect = timelineFrames.getBoundingClientRect();
                        Object.assign(dropIndicatorLine.style, {
                            position: 'fixed',
                            zIndex: '1000',
                            pointerEvents: 'none',
                            width: '3px',
                            height: `${timelineRect.height + 10}px`,
                            backgroundColor: '#818cf8',
                            borderRadius: '2px',
                            top: `${timelineRect.top - 5}px`,
                            left: `${moveEvent.clientX}px`,
                            boxShadow: '0 0 10px #6366f1'
                        });
                        document.body.appendChild(dropIndicatorLine);

                        placeholder = createPlaceholder();
                        draggedFrameElement.parentElement.insertBefore(placeholder, draggedFrameElement);
                        draggedFrameElement.style.opacity = '0.2';
                    }

                    if (isDragging) {
                        moveEvent.preventDefault(); 
                        
                        dropIndicatorLine.style.left = `${moveEvent.clientX}px`;

                        // Lógica robusta de proximidade para reordenação
                        const siblings = Array.from(timelineFrames.children).filter(
                            child => child !== draggedFrameElement && child !== placeholder && child.classList.contains('timeline-frame')
                        );

                        let closestSibling = null;
                        let minDistance = Infinity;

                        for (const sibling of siblings) {
                            const rect = sibling.getBoundingClientRect();
                            const center = rect.left + rect.width / 2;
                            const dist = Math.abs(moveEvent.clientX - center);
                            if (dist < minDistance) {
                                minDistance = dist;
                                closestSibling = sibling;
                            }
                        }

                        if (closestSibling) {
                            const rect = closestSibling.getBoundingClientRect();
                            const isAfter = moveEvent.clientX > (rect.left + rect.width / 2);
                            if (isAfter) {
                                closestSibling.parentNode.insertBefore(placeholder, closestSibling.nextSibling);
                            } else {
                                closestSibling.parentNode.insertBefore(placeholder, closestSibling);
                            }
                        } else {
                            timelineFrames.appendChild(placeholder);
                        }
                    }
                };

                const onPointerUp = (upEvent) => {
                    try { if(draggedFrameElement) draggedFrameElement.releasePointerCapture(upEvent.pointerId); } catch(err) {}
                    document.removeEventListener('pointermove', onPointerMove);
                    document.removeEventListener('pointerup', onPointerUp);
                    document.removeEventListener('pointercancel', onPointerUp);
                    document.body.style.cursor = '';
                    
                    if (isDragging) {
                        if (dropIndicatorLine) dropIndicatorLine.remove();
                        
                        if (placeholder) {
                            const newIndex = Array.from(placeholder.parentNode.children).indexOf(placeholder);
                            placeholder.remove();

                            const dropTargetIndex = (draggedFrameIndex < newIndex) ? newIndex - 1 : newIndex;
                        
                            if (draggedFrameIndex !== dropTargetIndex) {
                                const [draggedFrameData] = timelineFramesData.splice(draggedFrameIndex, 1);
                                timelineFramesData.splice(dropTargetIndex, 0, draggedFrameData);

                                if (currentFrameIndex === draggedFrameIndex) {
                                    currentFrameIndex = dropTargetIndex;
                                } else if (draggedFrameIndex < currentFrameIndex && dropTargetIndex >= currentFrameIndex) {
                                    currentFrameIndex--;
                                } else if (draggedFrameIndex > currentFrameIndex && dropTargetIndex <= currentFrameIndex) {
                                    currentFrameIndex++;
                                }
                            }
                        }

                    } else {
                        // --- LÓGICA DE CLIQUE ---
                        if(draggedFrameElement){
                            // --- CORREÇÃO: Garante que a seleção seja aplicada antes de mudar de quadro ---
                            if (selectionCanvas) applyAndSaveTransformation();
                            const clickedIndex = parseInt(draggedFrameElement.dataset.frameIndex, 10);
                            
                            // Lógica de Multi-Seleção
                            if (upEvent.shiftKey) {
                                const start = Math.min(currentFrameIndex, clickedIndex);
                                const end = Math.max(currentFrameIndex, clickedIndex);
                                selectedFrameIndices.clear();
                                for(let i=start; i<=end; i++) selectedFrameIndices.add(i);
                                currentFrameIndex = clickedIndex;
                            } else if (upEvent.ctrlKey || upEvent.metaKey) {
                                if (selectedFrameIndices.has(clickedIndex)) {
                                    if (selectedFrameIndices.size > 1) {
                                        selectedFrameIndices.delete(clickedIndex);
                                        if (currentFrameIndex === clickedIndex) {
                                            currentFrameIndex = Array.from(selectedFrameIndices)[0];
                                        }
                                    }
                                } else {
                                    selectedFrameIndices.add(clickedIndex);
                                    currentFrameIndex = clickedIndex;
                                }
                            } else {
                                if (currentFrameIndex !== clickedIndex) consolidateHistory(currentFrameIndex);
                                selectedFrameIndices.clear();
                                selectedFrameIndices.add(clickedIndex);
                                currentFrameIndex = clickedIndex;
                            }

                            currentLayerIndex = Math.min(preferredLayerIndex, timelineFramesData[currentFrameIndex].layers.length - 1);
                            refreshTimelineSelectionUI();
                        }
                    }
                    if(draggedFrameElement) draggedFrameElement.style.opacity = '1';

                    draggedFrameElement = null;
                    draggedFrameIndex = null;
                    isDragging = false;
                    dropIndicatorLine = null;
                    placeholder = null;

                    updateUI();
                    renderCanvas();
                };

                document.addEventListener('pointermove', onPointerMove);
                document.addEventListener('pointerup', onPointerUp);
                document.addEventListener('pointercancel', onPointerUp);
            });


            // Panel Logic
            const setupPanel = (button, panel) => {
                button.addEventListener('click', (e) => {
                    e.stopPropagation();
                    panel.classList.toggle('hidden');
                });
            };

            setupPanel(layersPanelBtn, layersPanel);
            setupPanel(brushesPanelBtn, brushesPanel);

            document.addEventListener('click', (e) => {
                if (!layersPanel.classList.contains('hidden') && !layersPanel.contains(e.target) && !layersPanelBtn.contains(e.target)) {
                    layersPanel.classList.add('hidden');
                }
                if (!brushesPanel.classList.contains('hidden') && !brushesPanel.contains(e.target) && !brushesPanelBtn.contains(e.target)) {
                    brushesPanel.classList.add('hidden');
                }
                if (!fileMenu.classList.contains('hidden') && !fileMenu.contains(e.target) && !fileMenuBtn.contains(e.target)) {
                    fileMenu.classList.add('hidden');
                }
            });
            
            // Configuração do Painel de Pincéis
            const brushes = [
                { type: 'normal', name: 'Normal' },
                { type: 'pencil', name: '6B' },                
                { type: 'spray', name: 'Spray' },
                { type: 'airbrush', name: 'Aerógrafo' }
            ];

            brushes.forEach(brush => {
                const brushBtn = document.createElement('button');
                brushBtn.className = `brush-btn w-full text-left p-2 bg-zinc-700 rounded-lg shadow-sm transition-colors duration-150 hover:bg-zinc-600`;
                if (brush.type === currentBrush.type) {
                    brushBtn.classList.add('bg-indigo-900/50', 'border', 'border-indigo-500');
                }
                brushBtn.dataset.brushType = brush.type;
                brushBtn.title = brush.name;

                const brushNameSpan = document.createElement('span');
                brushNameSpan.className = 'text-sm font-medium';
                brushNameSpan.textContent = brush.name;
                
                brushBtn.appendChild(brushNameSpan);
                brushesList.appendChild(brushBtn);
            });

            brushesList.addEventListener('click', (e) => {
                const btn = e.target.closest('.brush-btn');
                if (btn) {
                    setTool('brush');
                    brushesList.querySelectorAll('.brush-btn').forEach(b => {
                        b.classList.remove('bg-indigo-900/50', 'border', 'border-indigo-500');
                    });
                    btn.classList.add('bg-indigo-900/50', 'border', 'border-indigo-500');
                    
                    const brushType = btn.dataset.brushType;
                    currentBrush.type = brushType;
                    updateBrushUI(brushType); // Atualiza os sliders com os valores salvos
                }
            });


            // Lógica do Painel de Camadas
            let draggedLayerDiv = null;

            layersList.addEventListener('pointerdown', (e) => {
                const layerDiv = e.target.closest('.layer-item');
                const currentLayers = timelineFramesData[currentFrameIndex].layers;
                if (e.target.closest('.delete-layer') || e.target.closest('.rename-layer') || e.target.closest('.toggle-visibility') || e.target.classList.contains('layer-opacity-slider')) {
                    return;
                }
                if (layerDiv && !currentLayers[parseInt(layerDiv.dataset.layerIndex)].isBackground) {
                    draggedLayerDiv = layerDiv;
                    draggedLayerDiv.classList.add('dragging');
                    e.preventDefault();
                }
            });

            layersList.addEventListener('pointermove', (e) => {
                if (!draggedLayerDiv) return;
                e.preventDefault();
                const targetLayerDiv = e.target.closest('.layer-item');
                if (targetLayerDiv && draggedLayerDiv !== targetLayerDiv) {
                    const targetRect = targetLayerDiv.getBoundingClientRect();
                    const midPoint = targetRect.top + targetRect.height / 2;
                    const isBefore = e.clientY < midPoint;
                    
                    if (isBefore) {
                        layersList.insertBefore(draggedLayerDiv, targetLayerDiv);
                    } else {
                        layersList.insertBefore(draggedLayerDiv, targetLayerDiv.nextSibling);
                    }
                }
            });
            
            layersList.addEventListener('pointerup', () => {
                if (!draggedLayerDiv) return;

                const currentLayers = timelineFramesData[currentFrameIndex].layers;
                const newOrderDivs = Array.from(layersList.children);
                
                const oldDataIndex = parseInt(draggedLayerDiv.dataset.layerIndex);
                const newDataIndex = currentLayers.length - 1 - newOrderDivs.indexOf(draggedLayerDiv);
                
                // --- APLICA A REORDENAÇÃO EM TODOS OS FRAMES ---
                timelineFramesData.forEach(frame => {
                    const layerToMove = frame.layers.splice(oldDataIndex, 1)[0];
                    frame.layers.splice(newDataIndex, 0, layerToMove);
                });

                const bgLayer = currentLayers.find(l => l.isBackground);
                const bgIndex = currentLayers.indexOf(bgLayer);
                if (bgIndex !== 0) {
                    currentLayers.splice(bgIndex, 1);
                    currentLayers.unshift(bgLayer);
                }

                currentLayerIndex = newDataIndex;
                preferredLayerIndex = newDataIndex;

                draggedLayerDiv.classList.remove('dragging');
                draggedLayerDiv = null;

                updateUI();
                renderCanvas();
            });

            // --- LÓGICA DE EVENTOS DA LISTA DE CAMADAS (CORRIGIDA) ---
            layersList.addEventListener('click', e => {
                const layerDiv = e.target.closest('.layer-item');
                if (!layerDiv) return;

                const currentLayers = timelineFramesData[currentFrameIndex].layers;
                const allLayerDivs = Array.from(layersList.children);
                const clickedUIIndex = allLayerDivs.indexOf(layerDiv);
                const clickedDataIndex = currentLayers.length - 1 - clickedUIIndex;
                const clickedLayer = currentLayers[clickedDataIndex];

                // --- Lógica para Renomear ---
                if (e.target.closest('.rename-layer')) {
                    if (clickedLayer.isBackground) return;

                    const layerItem = e.target.closest('.layer-item');
                    const nameSpan = layerItem.querySelector('.layer-name');
                    
                    // Evita criar múltiplos inputs se clicar rápido
                    if (layerItem.querySelector('.rename-input')) return;

                    const input = document.createElement('input');
                    input.type = 'text';
                    input.className = 'rename-input text-sm font-medium bg-zinc-800 text-white border border-indigo-500 rounded px-1 mx-1 flex-grow min-w-0';
                    input.value = clickedLayer.name;
                    
                    nameSpan.style.display = 'none';
                    nameSpan.parentNode.insertBefore(input, nameSpan);
                    
                    input.focus();
                    input.select();
                    
                    // Impede propagação de eventos para não arrastar a camada enquanto digita
                    input.addEventListener('click', (ev) => ev.stopPropagation());
                    input.addEventListener('pointerdown', (ev) => ev.stopPropagation());

                    const finishRename = () => {
                        const newName = input.value.trim();
                        if (newName !== "") {
                            // Renomeia em TODOS os frames para manter consistência
                            timelineFramesData.forEach(frame => {
                                frame.layers[clickedDataIndex].name = newName;
                            });
                            updateUI();
                        }
                        updateLayerPanelAndHistoryIndicators();
                    };

                    input.addEventListener('blur', finishRename);
                    input.addEventListener('keydown', (ev) => {
                        if (ev.key === 'Enter') {
                            input.blur(); // Salva ao apertar Enter
                        } else if (ev.key === 'Escape') {
                            updateLayerPanelAndHistoryIndicators(); // Cancela ao apertar Esc
                        }
                        ev.stopPropagation();
                    });
                    return;
                }

                // --- Lógica para Apagar ---
                if (e.target.closest('.delete-layer:not([disabled])')) {
                    applyAndSaveTransformation();
                    // Remove a camada de TODOS os frames
                    timelineFramesData.forEach(frame => {
                        frame.layers.splice(clickedDataIndex, 1);
                    });
                    currentLayerIndex = Math.min(currentLayers.length - 1, clickedDataIndex > 0 ? clickedDataIndex - 1 : 0);
                    preferredLayerIndex = currentLayerIndex;
                    updateUI();
                    renderCanvas();
                    return;
                }

                // --- Lógica para Visibilidade ---
                if (e.target.closest('.toggle-visibility')) {
                    const newState = !clickedLayer.visible;
                    // Aplica visibilidade em TODOS os frames (comportamento de Track)
                    timelineFramesData.forEach(frame => {
                        frame.layers[clickedDataIndex].visible = newState;
                        frame.isDirty = true;
                    });
                    renderCanvas();
                    updateLayerPanelAndHistoryIndicators();
                    return;
                }

                // --- Lógica para Selecionar a Camada (ação padrão) ---
                if (currentLayerIndex !== clickedDataIndex) {
                    // --- CORREÇÃO: Garante que a seleção seja aplicada antes de mudar de camada ---
                    if (selectionCanvas) applyAndSaveTransformation();
                    currentLayerIndex = clickedDataIndex;
                    preferredLayerIndex = clickedDataIndex;
                    consolidateHistory(currentFrameIndex); // OTIMIZAÇÃO 2
                    updateLayerPanelAndHistoryIndicators(); // Leve, só atualiza o painel de camadas (que já está aberto)
                }
            });

            layersList.addEventListener('input', e => {
                if (e.target.classList.contains('layer-opacity-slider')) {
                    const layerDiv = e.target.closest('.layer-item');
                    const allLayerDivs = Array.from(layersList.children);
                    const clickedUIIndex = allLayerDivs.indexOf(layerDiv);
                    const clickedDataIndex = timelineFramesData[currentFrameIndex].layers.length - 1 - clickedUIIndex;
                    
                    timelineFramesData[currentFrameIndex].layers[clickedDataIndex].opacity = parseInt(e.target.value) / 100;
                    timelineFramesData[currentFrameIndex].isDirty = true; // OTIMIZAÇÃO 1
                    renderCanvas();
                    updateCurrentFrameThumbnail(); // Atualiza a miniatura sem redesenhar tudo
                }
            });
            
            addLayerBtn.addEventListener('pointerdown', (e) => {
                e.preventDefault();
                // --- CORREÇÃO: Garante que a seleção seja aplicada antes de adicionar uma nova camada ---
                if (selectionCanvas) applyAndSaveTransformation();
                if (e.button === 0) {
                    const currentLayers = timelineFramesData[currentFrameIndex].layers;
                    const newLayerName = `Camada ${currentLayers.length}`; // Background é 0, então length é o próximo índice
                    
                    // Adiciona a nova camada em TODOS os frames
                    timelineFramesData.forEach(frame => {
                        frame.layers.push(createLayer(newLayerName));
                    });

                    currentLayerIndex = currentLayers.length - 1;
                    preferredLayerIndex = currentLayerIndex;
                    updateUI(); // Precisa do "pesado" aqui para refazer as miniaturas com as novas camadas
                    renderCanvas();
                }
            });
            
            addLayerBtn.addEventListener('click', () => {
                // --- CORREÇÃO: Garante que a seleção seja aplicada antes de adicionar uma nova camada ---
                if (selectionCanvas) {
                    applyAndSaveTransformation(); // Aplica e já limpa o estado
                }
                const currentLayers = timelineFramesData[currentFrameIndex].layers;
                const newName = `Camada ${currentLayers.length}`;
                timelineFramesData.forEach(frame => {
                    frame.layers.push(createLayer(newName));
                });
                currentLayerIndex = currentLayers.length - 1;
                preferredLayerIndex = currentLayerIndex;
                renderCanvas(); updateUI();
            });

            onionSkinBtn.addEventListener('click', () => {
                onionSkinning = !onionSkinning;
                onionSkinBtn.classList.toggle('active', onionSkinning);
                // Não precisa marcar como dirty, pois o onion skin é desenhado em outro canvas
                renderCanvas();
            });
            onionOpacitySlider.addEventListener('input', (e) => {
                onionOpacity = parseInt(e.target.value) / 100;
                if(onionSkinning) renderCanvas();
            });
            
            // Listener para o input de duração
            frameDurationInput.addEventListener('change', (e) => {
                if (timelineFramesData.length > 0) {
                    let val = parseInt(e.target.value);
                    if (isNaN(val) || val < 1) val = 1;
                    e.target.value = val;
                    selectedFrameIndices.forEach(idx => {
                        if (timelineFramesData[idx]) {
                            timelineFramesData[idx].duration = val;
                        }
                    });
                    updateUI(); // Atualiza a UI para refletir a nova largura
                    updateTimelineWidths(); // Atualiza a largura total da timeline
                }
            });

            // Restaura o funcionamento das setas (Cima/Baixo) já que mudamos para type="text"
            frameDurationInput.addEventListener('keydown', (e) => {
                if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                    e.preventDefault();
                    let val = parseInt(e.target.value) || 1;
                    if (e.key === 'ArrowUp') val++; else val = Math.max(1, val - 1);
                    e.target.value = val;
                    frameDurationInput.dispatchEvent(new Event('change'));
                }
            });

            // Botões de incremento/decremento (Setinhas)
            btnDurInc.addEventListener('click', () => {
                let val = parseInt(frameDurationInput.value);
                if (isNaN(val)) val = 1;
                val++;
                frameDurationInput.value = val;
                frameDurationInput.dispatchEvent(new Event('change'));
            });

            btnDurDec.addEventListener('click', () => {
                let val = parseInt(frameDurationInput.value);
                if (isNaN(val)) val = 1;
                if (val > 1) val--;
                frameDurationInput.value = val;
                frameDurationInput.dispatchEvent(new Event('change'));
            });

            fpsSlider.addEventListener('input', (e) => {
                frameRate = parseInt(e.target.value);
                fpsValue.textContent = frameRate;
                updateTimelineWidths();
            });
            
            
           // FUNÇÃO CORRIGIDA: Aplica zoom/pan com proteção contra desaparecimento
            function applyTransform() {
                // Proteção de Segurança: Se os valores ficarem inválidos (NaN), reseta
                if (isNaN(panX) || isNaN(panY) || isNaN(scale) || scale <= 0) {
                    panX = 0;
                    panY = 0;
                    scale = 1;
                    console.warn("Resetando visualização corrompida.");
                }

                // Aplica a transformação
                canvasWrapper.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
                canvasWrapper.style.transformOrigin = '0 0';

                // Sincroniza o slider e o texto
                if (document.activeElement !== zoomSlider) {
                    zoomSlider.value = scale;
                    zoomValue.textContent = `${scale.toFixed(1)}x`;
                }
            }

            // Pequeno helper para rastrear teclas
            const keys = {};

            // --- Lógica do Menu de Arquivo e Exportação/Salvar ---
            
            function showLoadingModal(message) {
                loadingMessage.textContent = message;
                loadingModal.classList.remove('hidden');
            }
            
            function hideLoadingModal() {
                loadingModal.classList.add('hidden');
            }

            function getFrameAsCanvas(frameIndex, transparent = false) {
                const canvas = document.createElement('canvas');
                canvas.width = CANVAS_WIDTH;
                canvas.height = CANVAS_HEIGHT;
                renderFrameToContext(frameIndex, canvas.getContext('2d'), transparent);
                return canvas;
            }
            
            // Nova função para misturar todas as faixas de áudio em um único AudioBuffer
            async function mixAllAudioTracks() {
                if (!audioContext || audioTracks.length === 0) {
                    return null;
                }

                let totalDurationFrames = 0;
                timelineFramesData.forEach(f => totalDurationFrames += (f.duration || 1));
                const totalDuration = totalDurationFrames / frameRate;

                const totalSamples = Math.ceil(totalDuration * audioContext.sampleRate);
                const mixedBuffer = audioContext.createBuffer(2, totalSamples, audioContext.sampleRate);
                
                const channelDataL = mixedBuffer.getChannelData(0);
                const channelDataR = mixedBuffer.numberOfChannels > 1 ? mixedBuffer.getChannelData(1) : mixedBuffer.getChannelData(0);

                for (const track of audioTracks) {
                    const trackOffset = Math.floor(track.timelineStart * audioContext.sampleRate);
                    const trimStartSamples = Math.floor(track.trimStart * track.originalBuffer.sampleRate);
                    const trimDurationSamples = Math.ceil(track.trimDuration * track.originalBuffer.sampleRate);

                    const trackDataL = track.originalBuffer.getChannelData(0);
                    const trackDataR = track.originalBuffer.numberOfChannels > 1 ? track.originalBuffer.getChannelData(1) : trackDataL;

                    for (let i = 0; i < trimDurationSamples; i++) {
                        const targetIndex = trackOffset + i;
                        const sourceIndex = trimStartSamples + i;

                        if (targetIndex < totalSamples && sourceIndex < track.originalBuffer.length) {
                            channelDataL[targetIndex] += trackDataL[sourceIndex];
                            channelDataR[targetIndex] += trackDataR[sourceIndex];
                        }
                    }
                }
                
                return mixedBuffer;
            }
            
            // --- 5. ULTRA-FAST EXPORT (WEBCODECS HARDWARE ACCELERATION) ---
            async function exportAsVideo(transparent = false, withAudio = false) {
                if (timelineFramesData.length === 0) {
                    showMessage('Erro', 'Não há quadros para exportar.');
                    return;
                }

                if (typeof VideoEncoder === 'undefined') {
                    showMessage('Erro', 'Seu navegador não suporta WebCodecs. Use Chrome/Edge atualizado.');
                    return;
                }

                if (isPlaying) togglePlayState(); // Para a reprodução para evitar conflitos

                showLoadingModal('Inicializando renderização de alta qualidade...');
            
                try {
                    const width = CANVAS_WIDTH;
                    const height = CANVAS_HEIGHT;
                    const videoBitrate = 15_000_000; // 15 Mbps (Recomendado para YouTube 2K/4K)

                    // 1. Configurar Muxer
                    const muxer = new WebMMuxer.Muxer({
                        target: new WebMMuxer.ArrayBufferTarget(),
                        video: { codec: 'V_VP9', width, height, frameRate: frameRate },
                        audio: withAudio ? { codec: 'A_OPUS', sampleRate: 48000, numberOfChannels: 2 } : undefined
                    });

                    // Fila para garantir que a duração dos frames (especialmente o último) seja respeitada
                    const chunkDurations = [];

                    // 2. Configurar VideoEncoder
                    const videoEncoder = new VideoEncoder({
                        output: (chunk, meta) => {
                            const expectedDuration = chunkDurations.shift();
                            // Se o chunk vier sem duração (bug comum), recriamos com a duração correta
                            if (!chunk.duration && expectedDuration) {
                                const data = new Uint8Array(chunk.byteLength);
                                chunk.copyTo(data);
                                const newChunk = new EncodedVideoChunk({
                                    type: chunk.type, timestamp: chunk.timestamp, duration: expectedDuration, data: data
                                });
                                muxer.addVideoChunk(newChunk, meta);
                            } else {
                                muxer.addVideoChunk(chunk, meta);
                            }
                        },
                        error: e => console.error(e)
                    });
                    videoEncoder.configure({
                        codec: 'vp09.00.10.08', // VP9 Profile 0, Level 1 (Hardware Friendly)
                        width,
                        height,
                        bitrate: videoBitrate,
                        framerate: frameRate
                    });

                    // 3. Configurar AudioEncoder
                    let audioEncoder = null;
                    if (withAudio && audioTracks.length > 0) {
                        audioEncoder = new AudioEncoder({
                            output: (chunk, meta) => muxer.addAudioChunk(chunk, meta),
                            error: e => console.error(e)
                        });
                        audioEncoder.configure({
                            codec: 'opus',
                            sampleRate: 48000,
                            numberOfChannels: 2,
                            bitrate: 192000
                        });
                    }

                    // 4. Renderizar Vídeo (Frame a Frame)
                    const totalFrames = timelineFramesData.length;
                    let accumulatedTime = 0;
                    
                    for (let i = 0; i < totalFrames; i++) {
                        loadingMessage.textContent = `Renderizando vídeo... ${Math.round(((i + 1) / totalFrames) * 100)}%`;
                        const frameData = timelineFramesData[i];
                        const duration = frameData.duration || 1;
                        await new Promise(r => setTimeout(r, 0)); // Yield
                        
                        // Throttle se o encoder estiver sobrecarregado
                        while (videoEncoder.encodeQueueSize > 5) {
                            await new Promise(r => setTimeout(r, 10));
                        }

                        const frameCanvas = getFrameAsCanvas(i, transparent);
                        const frameDurationMicroseconds = (duration * 1000000) / frameRate;
                        const timestamp = accumulatedTime;
                        chunkDurations.push(frameDurationMicroseconds);
                        accumulatedTime += frameDurationMicroseconds;
                        
                        // Convert Canvas to ImageBitmap for GPU transfer
                        const bitmap = await createImageBitmap(frameCanvas);
                        const frame = new VideoFrame(bitmap, { timestamp, duration: frameDurationMicroseconds });
                        
                        // MANUAL GARBAGE COLLECTION
                        bitmap.close(); 
                        
                        videoEncoder.encode(frame, { keyFrame: i % 30 === 0 });
                        frame.close();
                    }

                    // 5. Processar Áudio
                    if (withAudio && audioTracks.length > 0) {
                        loadingMessage.textContent = `Processando áudio...`;
                        if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        
                        const mixedAudioBuffer = await mixAllAudioTracks();
                        if (mixedAudioBuffer) {
                            // Reamostrar para 48kHz (padrão Opus) usando OfflineAudioContext
                            const offlineCtx = new OfflineAudioContext(2, Math.ceil(mixedAudioBuffer.duration * 48000), 48000);
                            const source = offlineCtx.createBufferSource();
                            source.buffer = mixedAudioBuffer;
                            source.connect(offlineCtx.destination);
                            source.start();
                            const renderedBuffer = await offlineCtx.startRendering();

                            const dataL = renderedBuffer.getChannelData(0);
                            const dataR = renderedBuffer.getChannelData(1);
                            const interleaved = new Float32Array(dataL.length * 2);
                            for (let i = 0; i < dataL.length; i++) {
                                interleaved[i*2] = dataL[i];
                                interleaved[i*2+1] = dataR[i];
                            }

                            const chunkSize = 48000; // 1 segundo
                            for (let i = 0; i < interleaved.length; i += chunkSize * 2) {
                                const chunkData = interleaved.slice(i, i + chunkSize * 2);
                                if (chunkData.length === 0) break;
                                
                                const audioData = new AudioData({
                                    format: 'f32',
                                    sampleRate: 48000,
                                    numberOfFrames: chunkData.length / 2,
                                    numberOfChannels: 2,
                                    timestamp: (i / 2 / 48000) * 1000000,
                                    data: chunkData
                                });
                                audioEncoder.encode(audioData);
                                audioData.close();
                            }
                        }
                    }

                    // 6. Finalizar
                    await videoEncoder.flush();
                    if (audioEncoder) await audioEncoder.flush();
                    muxer.finalize();

                    const { buffer } = muxer.target;
                    const blob = new Blob([buffer], { type: 'video/webm' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        const fileName = `animacao${withAudio ? '_com_audio' : ''}${transparent ? '_transparente' : ''}.webm`;
                        a.download = fileName;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                        hideLoadingModal();
                        showMessage('Sucesso', 'Vídeo exportado com sucesso!');
            
                } catch (error) {
                    console.error('Erro durante a exportação do vídeo:', error);
                    showMessage('Erro', `Falha na exportação: ${error.message}`);
                    hideLoadingModal();
                }
            }
            async function exportAsPngSequence(transparent = false) {
                if (timelineFramesData.length === 0) {
                    showMessage('Erro', 'Não há quadros para exportar.');
                    return;
                }
                if (isPlaying) togglePlayState();
                showLoadingModal('Preparando PNGs...');
                const zip = new JSZip();

                for (let i = 0; i < timelineFramesData.length; i++) {
                    const frameCanvas = getFrameAsCanvas(i, transparent);
                    const blob = await new Promise(resolve => frameCanvas.toBlob(resolve, 'image/png'));
                    const frameNumber = String(i + 1).padStart(4, '0');
                    zip.file(`frame_${frameNumber}.png`, blob);
                    await new Promise(resolve => setTimeout(resolve, 0)); // Yield to main thread
                }
                
                showLoadingModal('Gerando arquivo ZIP...');
                zip.generateAsync({ type: "blob" }).then(function(content) {
                    const url = URL.createObjectURL(content);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `animacao_frames${transparent ? '_transparente' : ''}.zip`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    hideLoadingModal();
                    showMessage('Sucesso', 'Sequência de PNGs exportada com sucesso!');
                });
            }

            async function exportAsLayeredZip() {
                if (timelineFramesData.length === 0) {
                    showMessage('Erro', 'Não há quadros para exportar.');
                    return;
                }
                if (isPlaying) togglePlayState();
                showLoadingModal('Preparando ZIP com camadas...');
                const zip = new JSZip();
                
                // Cria um canvas temporário UMA VEZ para reutilizar
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = CANVAS_WIDTH;
                tempCanvas.height = CANVAS_HEIGHT;
                const tempCtx = tempCanvas.getContext('2d');

                for (let f_idx = 0; f_idx < timelineFramesData.length; f_idx++) {
                    const frame = timelineFramesData[f_idx];
                    const frameNumber = String(f_idx + 1).padStart(4, '0');
                    const frameFolder = zip.folder(`frame_${frameNumber}`);
                    
                    loadingMessage.textContent = `Processando Frame ${f_idx + 1}/${timelineFramesData.length}...`;

                    // Loop de baixo para cima (ordem de empilhamento)
                    for (let l_idx = 0; l_idx < frame.layers.length; l_idx++) {
                        const layer = frame.layers[l_idx];

                        // Pula o background ou camadas invisíveis
                        if (layer.isBackground || !layer.visible) {
                            continue;
                        }

                        const imageData = layer.history[layer.historyIndex];
                        if (!imageData) continue;

                        // Limpa o canvas temporário e desenha o ImageData da camada
                        tempCtx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                        tempCtx.putImageData(imageData, 0, 0);

                        // Converte o canvas para Blob (PNG)
                        const blob = await new Promise(resolve => tempCanvas.toBlob(resolve, 'image/png'));
                        
                        // Limpa o nome do arquivo para evitar caracteres inválidos
                        const safeName = layer.name.replace(/[^a-z0-9_-\s]/gi, '').replace(/\s+/g, '_');
                        // Adiciona um prefixo numérico para garantir a ordem de empilhamento
                        const fileName = `${String(l_idx).padStart(2, '0')}_${safeName}.png`;
                        
                        frameFolder.file(fileName, blob);
                    }
                    // Dá uma pausa para o navegador respirar e atualizar o modal
                    await new Promise(resolve => setTimeout(resolve, 0));
                }

                showLoadingModal('Gerando arquivo ZIP...');
                const content = await zip.generateAsync({
                    type: "blob",
                    compression: "DEFLATE",
                    compressionOptions: { level: 6 }
                }, (metadata) => {
                    loadingMessage.textContent = `Compactando... ${metadata.percent.toFixed(0)}%`;
                });
                
                const url = URL.createObjectURL(content);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'animacao_camadas.zip';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                hideLoadingModal();
                showMessage('Sucesso', 'ZIP com camadas exportado com sucesso!');
            }

            // --- UPDATE: Salvar/Carregar Projeto Otimizado ---

            async function saveProject() {
                if (timelineFramesData.length === 0) {
                    showMessage('Aviso', 'O projeto está vazio. Adicione alguns quadros para salvar.');
                    return;
                }
                showLoadingModal('Preparando o projeto...');

                try {
                    const serializableAudioTracks = audioTracks.map(track => ({
                        id: track.id,
                        fileName: track.fileName,
                        timelineStart: track.timelineStart,
                        trimStart: track.trimStart,
                        trimDuration: track.trimDuration,
                    }));                    

                    const projectData = {
                        version: '2.1.0', // Formato de salvamento simplificado
                        canvasSize: { width: CANVAS_WIDTH, height: CANVAS_HEIGHT },
                        fps: frameRate,
                        timelineFrames: [], // Será preenchido abaixo
                        audioTracks: serializableAudioTracks
                    };

                    const zip = new JSZip();
                    const framesFolder = zip.folder("frames");

                    // Processa cada frame para salvar apenas o estado atual
                    for (let f_idx = 0; f_idx < timelineFramesData.length; f_idx++) {
                        loadingMessage.textContent = `Processando Frame ${f_idx + 1}/${timelineFramesData.length}...`;
                        await new Promise(resolve => setTimeout(resolve, 0)); 

                        const originalFrame = timelineFramesData[f_idx];
                        const simplifiedFrame = {
                            duration: originalFrame.duration || 1,
                            layers: []
                        };

                        for (let l_idx = 0; l_idx < originalFrame.layers.length; l_idx++) {
                            const originalLayer = originalFrame.layers[l_idx];
                            const currentImageData = originalLayer.history[originalLayer.historyIndex];
                            const fileName = `f${f_idx}_l${l_idx}.bin`;

                            // Salva o binário do estado atual da camada
                            framesFolder.file(fileName, currentImageData.data.buffer);

                            // Cria a camada simplificada para o JSON
                            simplifiedFrame.layers.push({
                                name: originalLayer.name,
                                visible: originalLayer.visible,
                                opacity: originalLayer.opacity,
                                blendMode: originalLayer.blendMode || 'source-over',
                                isBackground: originalLayer.isBackground,
                                imageDataFile: fileName // Apenas a referência para o arquivo do estado atual
                            });
                        }
                        projectData.timelineFrames.push(simplifiedFrame);
                    }

                    zip.file("project.json", JSON.stringify(projectData));

                    const audioFolder = zip.folder("audio");
                    audioTracks.forEach(track => {
                        audioFolder.file(track.fileName, track.arrayBuffer);
                    });
                   
                    showLoadingModal('Compactando projeto...');
                    const content = await zip.generateAsync({
                        type: "blob",
                        compression: "DEFLATE",
                        compressionOptions: { level: 6 }
                    }, (metadata) => {
                         loadingMessage.textContent = `Compactando... ${metadata.percent.toFixed(0)}%`;
                    });
                    
                    const url = URL.createObjectURL(content);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'meu_projeto.adproj'; 
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);

                    hideLoadingModal();
                    showMessage('Sucesso', 'Projeto salvo com sucesso!');

                } catch (error) {
                    console.error("Erro ao salvar o projeto:", error);
                    hideLoadingModal();
                    showMessage('Erro', `Ocorreu um erro ao salvar o projeto: ${error.message}`);
                }
            }
            
            async function loadProject(file) {
                if (!file) return;
                if (!file.name.endsWith('.adproj') && !file.name.endsWith('.zip')) {
                    showMessage('Erro', 'Por favor, selecione um arquivo de projeto válido (.adproj).');
                    return;
                }
                showLoadingModal('Abrindo projeto...');
                try {
                    await loadModernZipProject(file);

                } catch (error) {
                    console.error("Erro ao carregar projeto:", error);
                    hideLoadingModal();
                    showMessage('Erro', `Não foi possível ler o arquivo do projeto. Pode estar corrompido. Detalhe: ${error.message}`);
                } finally {
                    loadProjectInput.value = '';
                }
            }

            async function loadModernZipProject(file) {
                try {
                    const zip = await JSZip.loadAsync(file);
                    const projectJsonFile = zip.file("project.json");
                    if (!projectJsonFile) throw new Error("Arquivo project.json não encontrado.");

                    const content = await projectJsonFile.async("string");
                    const projectData = JSON.parse(content);

                    const framesFolder = zip.folder("frames");
                    if (!framesFolder) throw new Error("Pasta 'frames' não encontrada no projeto.");

                    const loadedFrames = projectData.timelineFrames;
                    timelineFramesData = []; // Limpa os dados antigos
                    globalBackgroundLayer = null; // Reseta o background global

                    for (let f_idx = 0; f_idx < projectData.timelineFrames.length; f_idx++) {
                        showLoadingModal(`Carregando Frame ${f_idx + 1}/${projectData.timelineFrames.length}...`);
                        await new Promise(resolve => setTimeout(resolve, 0)); // Yield

                        const simplifiedFrame = projectData.timelineFrames[f_idx];
                        const newFullFrame = {
                            cachedCanvas: null, isDirty: true, puppetPins: [], bones: [], layers: []
                        };

                        for (const simplifiedLayer of simplifiedFrame.layers) {
                            if (simplifiedLayer.isBackground) {
                                if (!globalBackgroundLayer) {
                                    // Esta é a primeira camada de background que encontramos. Torna-a global.
                                    const imageFile = framesFolder.file(simplifiedLayer.imageDataFile);
                                    if (!imageFile) throw new Error(`Arquivo de imagem ${simplifiedLayer.imageDataFile} não encontrado.`);
                                    
                                    const data = await imageFile.async("uint8array");
                                    const imageData = new ImageData(new Uint8ClampedArray(data.buffer), projectData.canvasSize.width, projectData.canvasSize.height);

                                    globalBackgroundLayer = {
                                        ...simplifiedLayer,
                                        history: [imageData],
                                        historyIndex: 0
                                    };
                                }
                                // Adiciona o background (agora global) às camadas do frame
                                newFullFrame.layers.push(globalBackgroundLayer);
                            } else {
                                // É uma camada normal, processa como antes
                                const imageFile = framesFolder.file(simplifiedLayer.imageDataFile);
                                if (!imageFile) throw new Error(`Arquivo de imagem ${simplifiedLayer.imageDataFile} não encontrado.`);
                                
                                const data = await imageFile.async("uint8array");
                                const imageData = new ImageData(new Uint8ClampedArray(data.buffer), projectData.canvasSize.width, projectData.canvasSize.height);

                                newFullFrame.layers.push({
                                    ...simplifiedLayer,
                                    history: [imageData],
                                    historyIndex: 0
                                });
                            }
                        }
                        timelineFramesData.push(newFullFrame);
                    }
                    // Aplica a duração correta ao objeto do frame principal
                    timelineFramesData.forEach((frame, i) => frame.duration = projectData.timelineFrames[i].duration || 1);
                  

                    audioTracks = [];
                    if (projectData.audioTracks && projectData.audioTracks.length > 0) {
                        showLoadingModal('Decodificando áudios...');
                        if (!audioContext) audioContext = new AudioContext();
                        const audioPromises = projectData.audioTracks.map(async (trackMeta) => {
                            const audioFile = zip.file(`audio/${trackMeta.fileName}`);
                            if (!audioFile) {
                                console.warn(`Arquivo de áudio ${trackMeta.fileName} não encontrado.`);
                                return null;
                            }
                            const arrayBuffer = await audioFile.async("arraybuffer");
                            const originalBuffer = await audioContext.decodeAudioData(arrayBuffer.slice(0));
                            return { ...trackMeta, arrayBuffer, originalBuffer, element: null };
                        });
                        const loadedTracks = await Promise.all(audioPromises);
                        audioTracks = loadedTracks.filter(track => track !== null);
                    }
                    
                    frameRate = projectData.fps || 12;
                    fpsSlider.value = frameRate;
                    fpsValue.textContent = frameRate;
                    currentFrameIndex = 0;
                    selectedFrameIndices.clear();
                    selectedFrameIndices.add(0);
                    currentLayerIndex = timelineFramesData[0]?.layers.length > 1 ? 1 : 0;
                    preferredLayerIndex = currentLayerIndex;
                    
                    // --- CORREÇÃO PUPPET ---
                    // Garante que os pinos do primeiro quadro sejam carregados na UI.
                    puppetPins = timelineFramesData[0]?.puppetPins || [];
                    // ---------------------

                    resetTransformationState(); // Garante que ferramentas como o puppet sejam reiniciadas

                    renderCanvas();
                    updateUI();
                    renderAllAudioTracks();
                    updateTimelineWidths();
                    hideLoadingModal();
                    showMessage('Sucesso', 'Projeto carregado com sucesso!');
                } catch (e) {
                    throw new Error(`Falha ao processar projeto ZIP: ${e.message}`);
                }
            }

            function resetProject() {
                // Para a reprodução se estiver ativa
                if (isPlaying) {
                    togglePlayState();
                }
                
                // Limpa os dados principais
                timelineFramesData = [];
                audioTracks = [];
                selectedFrameIndices.clear();
                selectedFrameIndices.add(0);
                
                // Reinicia o estado da aplicação
                resetTransformationState(); // Limpa ferramentas de seleção/puppet
                setupInitialLayers();       // Cria o primeiro quadro e camadas
                
                // Atualiza toda a interface do usuário para refletir o estado de um projeto novo
                renderCanvas();
                updateUI();
                renderAllAudioTracks();
                updateTimelineWidths();
            }

            // MODIFICAÇÃO na função importAudio
            async function importAudio(file) {
                if (!audioContext) {
                    audioContext = new AudioContext();
                }
                showLoadingModal(`Processando: ${file.name}`);
                
                try {
                    const arrayBuffer = await file.arrayBuffer();
                    // Crie uma cópia do ArrayBuffer para guardar, pois decodeAudioData pode "consumi-lo"
                    const savedArrayBuffer = arrayBuffer.slice(0); 
                    const originalBuffer = await audioContext.decodeAudioData(arrayBuffer);
                    
                    let newTrack = {
                        id: `audio_${Date.now()}_${Math.random()}`,
                        fileName: file.name, // <-- IMPORTANTE: guardar nome do arquivo
                        arrayBuffer: savedArrayBuffer, // <-- IMPORTANTE: guardar os dados do arquivo original
                        originalBuffer: originalBuffer,
                        timelineStart: getFrameStartTime(currentFrameIndex), // <-- ALTERAÇÃO PRINCIPAL: Usa tempo real acumulado
                        trimStart: 0,
                        trimDuration: Math.min(originalBuffer.duration, 2),
                        element: null
                    };

                    audioTracks.push(newTrack);
                    renderAllAudioTracks();
                    hideLoadingModal();
                } catch (error) {
                    console.error('Erro ao decodificar áudio:', error);
                    hideLoadingModal();
                    showMessage('Erro', `Não foi possível carregar o arquivo de áudio: ${file.name}.`);
                }
                importAudioInput.value = '';
            }

            function sliceAudioBuffer(buffer, start, duration) {
                const end = start + duration;
                if (duration <= 0 || start < 0 || end > buffer.duration + 0.01) {
                    return null;
                }
                const newBuffer = audioContext.createBuffer(
                    buffer.numberOfChannels,
                    Math.ceil(buffer.sampleRate * duration),
                    buffer.sampleRate
                );
                for (let i = 0; i < buffer.numberOfChannels; i++) {
                    const newChannelData = newBuffer.getChannelData(i);
                    const oldChannelData = buffer.getChannelData(i);
                    const startSample = Math.floor(start * buffer.sampleRate);
                    const endSample = startSample + newChannelData.length;
                    newChannelData.set(oldChannelData.subarray(startSample, endSample));
                }
                return newBuffer;
            }
            
            function deleteAudioTrack(trackId) {
                const trackIndex = audioTracks.findIndex(t => t.id === trackId);
                if (trackIndex > -1) {
                    audioTracks.splice(trackIndex, 1);
                    renderAllAudioTracks();
                }
            }
            
            function renderAllAudioTracks() {
                if(!audioTimelineWrapper) return;
                audioTimelineWrapper.innerHTML = '';
                audioTracks.forEach(track => {
                    const clipElement = createAudioClipUI(track);
                    audioTimelineWrapper.appendChild(clipElement);
                });
                updateTimelineWidths();
            }


            function createAudioClipUI(track) {
                const clip = document.createElement('div');
                clip.className = 'audio-clip';
                clip.dataset.trackId = track.id;

                const waveformCanvas = document.createElement('canvas');
                waveformCanvas.className = 'waveform-canvas';

                const handleLeft = document.createElement('div');
                handleLeft.className = 'resize-handle left';

                const handleRight = document.createElement('div');
                handleRight.className = 'resize-handle right';
                
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'delete-audio-btn';
                deleteBtn.textContent = 'X';
                deleteBtn.title = 'Excluir Áudio';
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    deleteAudioTrack(track.id);
                });
                
                clip.append(deleteBtn, waveformCanvas, handleLeft, handleRight);
                track.element = clip;

                drawWaveform(waveformCanvas, track.originalBuffer);
                updateAudioClipUI(track);
                
                return clip;
            }

            function drawWaveform(canvas, buffer) {
                // A largura do canvas agora é determinada pela duração e pela escala de quadros
                const FRAME_WIDTH = 54;
                const FRAME_SPACING = 0;
                const totalWidthPerFrame = FRAME_WIDTH + FRAME_SPACING;
                const pixelsPerSecond = (totalWidthPerFrame * frameRate);

                const ctx = canvas.getContext('2d');
                const data = buffer.getChannelData(0);
                
                const canvasWidth = buffer.duration * pixelsPerSecond;
                const height = audioTrackContainer.offsetHeight;
                
                canvas.width = canvasWidth;
                canvas.height = height;
                
                ctx.strokeStyle = 'rgba(173, 216, 230, 0.9)'; // Light blue
                ctx.lineWidth = 1;
                ctx.beginPath();

                const totalSamples = data.length;
                const step = Math.max(1, Math.ceil(totalSamples / canvas.width));
                const amp = height / 2;
                
                for (let i = 0; i < canvas.width; i++) {
                    let min = 1.0;
                    let max = -1.0;
                    for (let j = 0; j < step; j++) {
                        const index = Math.floor(i * step) + j;
                        if (index >= totalSamples) break;
                        const datum = data[index];
                        if (datum < min) min = datum;
                        if (datum > max) max = datum;
                    }
                    ctx.moveTo(i, (1 + min) * amp);
                    ctx.lineTo(i, (1 + max) * amp);
                }
                ctx.stroke();
            }

            function updateTimelineWidths() {
                const FRAME_WIDTH = 54;
                const FRAME_SPACING = 0;
                const HEADER_WIDTH = 140; // Largura do cabeçalho
                // Calcula largura total baseada na soma das durações
                let totalDurationUnits = 0;
                timelineFramesData.forEach(f => totalDurationUnits += (f.duration || 1));
                
                const totalWidth = totalDurationUnits * (FRAME_WIDTH + FRAME_SPACING); 
                timelineContentWrapper.style.width = `${Math.max(600, HEADER_WIDTH + totalWidth)}px`; // Soma o cabeçalho
                drawFrameMarkers();
            }


            function updateAudioClipUI(track) {
                if (!track || !track.element) return;
                const FRAME_WIDTH = 54;
                const FRAME_SPACING = 0;
                const totalWidthPerFrame = FRAME_WIDTH + FRAME_SPACING;
                const pixelsPerSecond = totalWidthPerFrame * frameRate;

                const clipLeft = (track.timelineStart * pixelsPerSecond);
                const clipWidth = track.trimDuration * pixelsPerSecond;
                track.element.style.left = `${clipLeft}px`;
                track.element.style.width = `${clipWidth}px`;
                
                const waveformCanvas = track.element.querySelector('.waveform-canvas');
                waveformCanvas.style.width = `${track.originalBuffer.duration * pixelsPerSecond}px`;
                waveformCanvas.style.left = `-${track.trimStart * pixelsPerSecond}px`;

                updateTimelineWidths();
            }

            async function importImageSequence(files) {
                const sortedFiles = Array.from(files).sort((a, b) => a.name.localeCompare(b.name, undefined, { numeric: true }));

                if (sortedFiles.length === 0) return;

                // Helper function to check if a layer is empty (transparent)
                function isLayerEmpty(layer) {
                    if (!layer || !layer.history || layer.history.length === 0) return true;
                    const imageData = layer.history[layer.historyIndex].data;
                    for (let i = 3; i < imageData.length; i += 4) {
                        if (imageData[i] !== 0) return false; // Found a non-transparent pixel
                    }
                    return true;
                }

                showLoadingModal('Importando sequência de imagens...');

                // Check if the current project is "empty" (one default frame with an empty drawing layer)
                const isProjectEmpty = timelineFramesData.length === 1 &&
                                    timelineFramesData[0].layers.length === 2 &&
                                    isLayerEmpty(timelineFramesData[0].layers[1]);

                let isFirstImageProcessed = false;

                for (let i = 0; i < sortedFiles.length; i++) {
                    const file = sortedFiles[i];
                    loadingMessage.textContent = `Processando imagem ${i + 1}/${sortedFiles.length}: ${file.name}`;

                    await new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            const img = new Image();
                            img.onload = () => {
                                let frameToUpdateIndex;

                                // Determine which frame to update
                                if (!isFirstImageProcessed && isProjectEmpty) {
                                    frameToUpdateIndex = 0;
                                } else {
                                    // Add a new blank frame and use it
                                    const newFrame = {
                                        duration: 1, cachedCanvas: null, isDirty: true, puppetPins: [], bones: [],
                                        layers: [
                                            globalBackgroundLayer // Usa o background compartilhado
                                        ]
                                    };
                                    // Adiciona as outras camadas vazias para manter a estrutura
                                    const layerCount = timelineFramesData[0].layers.length;
                                    for(let k=1; k<layerCount; k++) {
                                        newFrame.layers.push(createLayer(timelineFramesData[0].layers[k].name));
                                    }
                                    timelineFramesData.push(newFrame);
                                    frameToUpdateIndex = timelineFramesData.length - 1;
                                }

                                const targetLayer = timelineFramesData[frameToUpdateIndex].layers[currentLayerIndex];
                                const tempCanvas = document.createElement('canvas');
                                tempCanvas.width = CANVAS_WIDTH; tempCanvas.height = CANVAS_HEIGHT;
                                const tempCtx = tempCanvas.getContext('2d');
                                tempCtx.drawImage(img, 0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                                
                                const newImageData = tempCtx.getImageData(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                                targetLayer.history = [newImageData];
                                targetLayer.historyIndex = 0;
                                
                                timelineFramesData[frameToUpdateIndex].isDirty = true;
                                isFirstImageProcessed = true;
                                resolve();
                            };
                            img.onerror = reject;
                            img.src = e.target.result;
                        };
                        reader.onerror = reject;
                        reader.readAsDataURL(file);
                    });
                }

                currentFrameIndex = timelineFramesData.length - 1;
                selectedFrameIndices.clear(); selectedFrameIndices.add(currentFrameIndex);

                renderCanvas(); updateUI(); updateTimelineWidths();
                hideLoadingModal();
                showMessage('Sucesso', `${sortedFiles.length} imagens importadas como quadros.`);
                importSequenceInput.value = '';
            }

            function importImage(file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    if (timelineFramesData[currentFrameIndex].layers[currentLayerIndex].isBackground) {
                        showMessage('Aviso', 'Selecione uma camada diferente do fundo para importar imagens.');
                        return;
                    }

                    const img = new Image();
                    img.onload = () => {                        
                        // Se já houver uma seleção ativa, aplica-a antes de importar a nova imagem.
                        if (selectionCanvas) {
                            applyAndSaveTransformation();
                        }

                        if (timelineFramesData.length === 0) {
                            setupInitialLayers(); // Garante que há um quadro para trabalhar
                        }

                        // 1. Cria um novo canvas de seleção com o tamanho original da imagem.
                        selectionCanvas = document.createElement('canvas');
                        selectionCanvas.width = img.width;
                        selectionCanvas.height = img.height;
                        selectionCanvas.getContext('2d').drawImage(img, 0, 0);

                        // 2. Define a transformação inicial para centralizar a imagem sem redimensionar.
                        selectionTransform = {
                            x: (CANVAS_WIDTH - img.width) / 2,
                            y: (CANVAS_HEIGHT - img.height) / 2,
                            width: img.width,
                            height: img.height,
                            rotation: 0
                        };

                        // 3. Ativa a ferramenta de seleção e atualiza a tela.
                        setTool('selection');
                        renderCanvas();
                        showMessage('Sucesso', `A imagem "${file.name}" foi importada.`);
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
                importImageInput.value = ''; // Limpa o input para permitir importar a mesma imagem novamente
            }

            fileMenuBtn.addEventListener('click', (e) => {
                                         e.stopPropagation();
                                         fileMenu.classList.toggle('hidden');
            });
            // Perto de onde você tem 'exportPngBtn.addEventListener'

           // Listeners do Menu de Exportação
            exportPngBtn.addEventListener('click', () => { exportAsPngSequence(false); fileMenu.classList.add('hidden'); });
            exportTransparentPngBtn.addEventListener('click', () => { exportAsPngSequence(true); fileMenu.classList.add('hidden'); });
            exportLayersZipBtn.addEventListener('click', () => { exportAsLayeredZip(); fileMenu.classList.add('hidden'); });
            
            exportVideoBtn.addEventListener('click', () => { exportAsVideo(false, false); fileMenu.classList.add('hidden'); });
            exportTransparentVideoBtn.addEventListener('click', () => { exportAsVideo(true, false); fileMenu.classList.add('hidden'); });
            exportVideoAudioBtn.addEventListener('click', () => { exportAsVideo(false, true); fileMenu.classList.add('hidden'); });
            exportTransparentVideoAudioBtn.addEventListener('click', () => { exportAsVideo(true, true); fileMenu.classList.add('hidden'); });

            // Listeners de Salvar/Carregar
            saveProjectBtn.addEventListener('click', () => { saveProject(); fileMenu.classList.add('hidden'); });
            loadProjectBtn.addEventListener('click', () => { loadProjectInput.click(); fileMenu.classList.add('hidden'); });
            loadProjectInput.addEventListener('change', (e) => { loadProject(e.target.files[0]); });
            importImageBtn.addEventListener('click', () => { importImageInput.click(); fileMenu.classList.add('hidden'); });
            importImageInput.addEventListener('change', (e) => { if (e.target.files[0]) { importImage(e.target.files[0]); } });
            importSequenceBtn.addEventListener('click', () => { importSequenceInput.click(); fileMenu.classList.add('hidden'); });
            importSequenceInput.addEventListener('change', (e) => { 
                if (e.target.files.length > 0) {
                    importImageSequence(e.target.files);
                }
            });
            importAudioBtn.addEventListener('click', () => { importAudioInput.click(); fileMenu.classList.add('hidden'); });
            importAudioInput.addEventListener('change', (e) => { 
                for(const file of e.target.files) {
                    importAudio(file);
                }
            });

            // --- OTIMIZAÇÃO: Cache de Playback ---
            function updateFrameCache(frameIndex) {
                const frame = timelineFramesData[frameIndex];
                if (!frame) return;

                // Reutiliza o canvas de cache se ele já existir
                if (!frame.cachedCanvas) {
                    frame.cachedCanvas = document.createElement('canvas');
                    frame.cachedCanvas.width = CANVAS_WIDTH;
                    frame.cachedCanvas.height = CANVAS_HEIGHT;
                }
                
                const cacheCtx = frame.cachedCanvas.getContext('2d');
                // Usa a função otimizada para renderizar diretamente no cache
                // transparent=true para que a miniatura mostre o checkerboard corretamente
                renderFrameToContext(frameIndex, cacheCtx, true);
                
                frame.isDirty = false; // Marca o frame como "limpo"
            }
            
            function setupInitialLayers() {
                // Cria a camada de background única e compartilhada
                globalBackgroundLayer = createLayer('Background', { isBackground: true, fillWhite: true });

                const firstFrame = {
                    duration: 1,
                    cachedCanvas: null,
                    isDirty: true,
                    puppetPins: [], // Adiciona a propriedade de pinos ao frame inicial
                    bones: [],
                    layers: [
                        globalBackgroundLayer, // Referencia o background global
                        createLayer('Camada 1')
                    ]
                };
                timelineFramesData.push(firstFrame);
                currentLayerIndex = 1; 
                preferredLayerIndex = 1;
            }
            
            const handlePuppetMove = (e) => {
                const pos = getMousePos(mainCanvas, e);
                
                if (activeWarpNode && activeWarpNode.type === 'puppet') {
                    let pin, grid;
                    if (activeWarpNode.puppetIndex === -1) {
                        pin = puppetPins[activeWarpNode.pinIndex];
                        grid = warpGrid;
                    } else {
                        pin = puppets[activeWarpNode.puppetIndex].pins[activeWarpNode.pinIndex];
                        grid = puppets[activeWarpNode.puppetIndex].grid;
                    }
                    
                    const oldX = pin.x;
                    const oldY = pin.y;

                    // 1. Mover o pino
                    pin.x = pos.x;
                    pin.y = pos.y;

                    const deltaX = pin.x - oldX;
                    const deltaY = pin.y - oldY;

                    // 2. Deformar a grade (warpGrid) com base no movimento do pino
                    if (grid) {
                        grid.forEach(row => {
                            row.forEach(point => {
                                // Calcula a distância do ponto da grade para a posição ORIGINAL do pino
                                const dist = Math.hypot(point.ox - pin.ox, point.oy - pin.oy);
                                
                                // O fator de influência diminui com a distância.
                                // O '150' define o raio de influência. Ajuste para mais ou menos efeito.
                                const influence = Math.max(0, 1 - (dist / 150));
                                
                                // Aplica o movimento ao ponto da grade, ponderado pela influência
                                point.x += deltaX * influence;
                                point.y += deltaY * influence;
                            });
                        });
                    }
                    renderCanvas();
                } else if (activeWarpNode && activeWarpNode.type === 'puppet-grid') {
                    // --- NOVA LÓGICA: Deformação Livre (Soft Body) ---
                    let grid;
                    if (activeWarpNode.puppetIndex === -1) {
                        grid = warpGrid;
                    } else {
                        grid = puppets[activeWarpNode.puppetIndex].grid;
                    }

                    const activePt = grid[activeWarpNode.r][activeWarpNode.c];
                    const oldX = activePt.x;
                    const oldY = activePt.y;
                    
                    activePt.x = pos.x;
                    activePt.y = pos.y;
                    
                    const deltaX = activePt.x - oldX;
                    const deltaY = activePt.y - oldY;
                    
                    const radius = 150; // Raio de influência do "grab"
                    
                    grid.forEach(row => {
                        row.forEach(pt => {
                            if (pt === activePt) return;
                            // Usa distância atual para sensação de "agarrar" a malha
                            const dist = Math.hypot(pt.x - oldX, pt.y - oldY);
                            
                            if (dist < radius) {
                                // Decaimento quadrático suave
                                const falloff = Math.pow(1 - dist / radius, 2);
                                pt.x += deltaX * falloff;
                                pt.y += deltaY * falloff;
                            }
                        });
                    });
                    renderCanvas();
                }
            };
            
            const handlePuppetUp = () => {
                activeWarpNode = null;
                window.removeEventListener('pointermove', handlePuppetMove);
                window.removeEventListener('pointerup', handlePuppetUp);
            };

            // NOVA FUNÇÃO: "Carimba" a deformação atual sem sair da ferramenta
            function commitPuppetDeformation() {
                if (!selectionCanvas || !warpGrid) return;

                // 1. Pega a imagem da camada atual
                const currentLayers = timelineFramesData[currentFrameIndex].layers;
                const frame = currentLayers[currentLayerIndex];
                const targetImageData = frame.history[frame.historyIndex];

                // 2. Cria um canvas temporário para mesclar a camada com a deformação
                const finalCanvas = document.createElement('canvas');
                finalCanvas.width = CANVAS_WIDTH;
                finalCanvas.height = CANVAS_HEIGHT;
                const finalCtx = finalCanvas.getContext('2d');
                finalCtx.putImageData(targetImageData, 0, 0);

                // 3. Desenha a malha deformada por cima
                // CORREÇÃO AQUI: Passamos FALSE para não desenhar a grade
                renderWarpedSelection(finalCtx, warpGrid, selectionCanvas, false);

                // 4. Salva o resultado como um novo estado no histórico
                saveHistoryState(finalCtx.getImageData(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT));

                // 5. ATUALIZA O ESTADO BASE: A mágica acontece aqui!
                // A imagem original da seleção (selectionCanvas) é apagada, pois já foi mesclada.
                selectionCanvas.getContext('2d').clearRect(0, 0, selectionCanvas.width, selectionCanvas.height);

                // A posição "original" (ox, oy) de cada pino e nó da grade é atualizada para a posição atual.
                // Isso faz com que a pose atual se torne a nova pose "neutra".
                puppetPins.forEach(pin => {
                    pin.ox = pin.x;
                    pin.oy = pin.y;
                });
                warpGrid.forEach(row => row.forEach(point => {
                    point.ox = point.x;
                    point.oy = point.y;
                }));
            }
            // --- Lógica de Interação de Áudio ---
            const FRAME_WIDTH = 54;
            const FRAME_SPACING = 4;
            const totalWidthPerFrame = FRAME_WIDTH + FRAME_SPACING;
            const pixelsPerSecond = () => totalWidthPerFrame * frameRate;




            let audioInteractionMode = null;
            let audioInteractionStartX = 0;
            let initialAudioState = {};
            let activeTrackId = null;

            audioTimelineWrapper.addEventListener('pointerdown', (e) => {
                const targetClipEl = e.target.closest('.audio-clip');
                const isResizeHandle = e.target.classList.contains('resize-handle');
                const isDeleteBtn = e.target.classList.contains('delete-audio-btn');

                if (!targetClipEl || isDeleteBtn) return;

                if (e.button !== 0 && !isResizeHandle) {
                    return;
                }

                activeTrackId = targetClipEl.dataset.trackId;
                const track = audioTracks.find(t => t.id === activeTrackId);
                if (!track) return;

                audioInteractionStartX = e.clientX;
                initialAudioState = {
                    timelineStart: track.timelineStart,
                    trimStart: track.trimStart,
                    trimDuration: track.trimDuration
                };

                if (isResizeHandle) {
                    audioInteractionMode = e.target.classList.contains('left') ? 'resize-left' : 'resize-right';
                } else {
                    audioInteractionMode = 'drag-clip';
                    targetClipEl.classList.add('dragging');
                }

                e.preventDefault();

                const onMouseMove = (moveEvent) => {
                    if (!audioInteractionMode || !activeTrackId) return;
                    const activeTrack = audioTracks.find(t => t.id === activeTrackId);
                    if (!activeTrack) return;

                    const dx = moveEvent.clientX - audioInteractionStartX;
                    const deltaTime = dx / pixelsPerSecond();

                    if (audioInteractionMode === 'drag-clip') {
                        const newTimelineStart = initialAudioState.timelineStart + deltaTime;
                        activeTrack.timelineStart = Math.max(0, newTimelineStart);
                    } else if (audioInteractionMode === 'resize-left') {
                        const newTrimStart = initialAudioState.trimStart + deltaTime;
                        const newTrimDuration = initialAudioState.trimDuration - deltaTime;

                        if (newTrimDuration > 0.1 && newTrimStart >= 0) {
                            activeTrack.trimStart = newTrimStart;
                            activeTrack.trimDuration = newTrimDuration;
                            activeTrack.timelineStart = initialAudioState.timelineStart + deltaTime;
                        }
                    } else if (audioInteractionMode === 'resize-right') {
                        const newTrimDuration = initialAudioState.trimDuration + deltaTime;
                        if (newTrimDuration > 0.1 && (activeTrack.trimStart + newTrimDuration) <= activeTrack.originalBuffer.duration) {
                            activeTrack.trimDuration = newTrimDuration;
                        }
                    }
                    updateAudioClipUI(activeTrack);
                };

                const onMouseUp = () => {
                    if (targetClipEl) {
                        targetClipEl.classList.remove('dragging');
                    }
                    audioInteractionMode = null;
                    document.removeEventListener('pointermove', onMouseMove);
                    document.removeEventListener('pointerup', onMouseUp);
                };

                document.addEventListener('pointermove', onMouseMove);
                document.addEventListener('pointerup', onMouseUp);
            });

        // ... (final do código)
            
            // Initial setup
            setupInitialLayers();
            initBrushTextures(); // Inicializa as texturas dos pincéis
            updateUI();
            
            // Renderiza com um pequeno delay para garantir que o CSS carregou
            setTimeout(() => {
                resizeCanvas();
                renderCanvas();
                updateBrushUI('pencil');
            }, 100);
            
            animate();
        });
</script>
    </script>
</body>

</html>
